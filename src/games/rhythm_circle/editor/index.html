<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rhythm Circle - Map Editor</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@400;500;700&display=swap"
        rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: #0a0a1a;
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            user-select: none;
            /* Make whole editor non-selective */
        }

        header {
            background: #111;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #333;
        }

        .logo {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            color: #ff3366;
        }

        .toolbar {
            display: flex;
            gap: 10px;
        }

        .btn {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.85rem;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn.primary {
            background: #ff3366;
            color: #fff;
        }

        .btn.primary:hover {
            background: #ff4477;
        }

        .btn.secondary {
            background: #333;
            color: #ccc;
        }

        .btn.secondary:hover {
            background: #444;
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 300px;
            background: #111;
            border-right: 1px solid #333;
            padding: 20px;
            overflow-y: auto;
        }

        .sidebar h3 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            color: #ff3366;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            font-size: 0.85rem;
            color: #888;
            margin-bottom: 5px;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px;
            background: #1a1a2a;
            border: 1px solid #333;
            border-radius: 5px;
            color: #fff;
            font-family: inherit;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #ff3366;
        }

        .editor-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .preview-canvas-container {
            height: 300px;
            background: #0a0a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            border-bottom: 1px solid #333;
        }

        #preview-canvas {
            max-width: 100%;
            max-height: 100%;
        }

        .timeline-container {
            flex: 1;
            background: #0d0d1d;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .timeline-controls {
            padding: 15px;
            background: #111;
            display: flex;
            align-items: center;
            gap: 15px;
            border-bottom: 1px solid #333;
        }

        .time-display {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            color: #33ccff;
            min-width: 100px;
        }

        .play-btn {
            width: 40px;
            height: 40px;
            background: #ff3366;
            border: none;
            border-radius: 50%;
            color: #fff;
            font-size: 1.2rem;
            cursor: pointer;
        }

        .timeline-scroll {
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
            position: relative;
        }

        #timeline {
            height: 200px;
            min-width: 100%;
            position: relative;
            background: linear-gradient(to right, #0d0d1d, #1a1a2a);
            user-select: none;
            /* Prevent text selection */
        }

        .timeline-ruler {
            position: absolute;
            top: 0;
            left: 0;
            height: 30px;
            width: 100%;
            background: #111;
            border-bottom: 1px solid #333;
        }

        .timeline-tracks {
            position: absolute;
            top: 30px;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .track {
            height: 40px;
            border-bottom: 1px solid #222;
            position: relative;
        }

        .track.red {
            background: rgba(255, 51, 102, 0.1);
        }

        .track.blue {
            background: rgba(51, 204, 255, 0.1);
        }

        .track.special {
            background: rgba(255, 204, 0, 0.1);
        }

        .track-label {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.75rem;
            color: #666;
            text-transform: uppercase;
        }

        .note-marker {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            border: 2px solid #fff;
        }

        .note-marker.red {
            background: #ff3366;
            top: 50%;
            box-shadow: 0 0 5px #ff3366;
        }

        .note-marker.blue {
            background: #33ccff;
            top: 50%;
            box-shadow: 0 0 5px #33ccff;
        }

        .note-marker.hold {
            background: #ffcc00;
        }

        .note-marker.spam {
            background: #33ff66;
            border-style: dashed;
        }

        .note-marker:hover {
            transform: translate(-50%, -50%) scale(1.2);
        }

        .note-marker.selected {
            box-shadow: 0 0 10px #fff;
        }

        .hold-trail {
            position: absolute;
            height: 10px;
            background: rgba(255, 204, 0, 0.4);
            top: 50%;
            transform: translateY(-50%);
            border-radius: 5px;
        }

        .hold-resize-handle {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 8px;
            background: rgba(255, 255, 255, 0.5);
            cursor: e-resize;
            border-radius: 0 4px 4px 0;
        }

        .hold-resize-handle:hover {
            background: #fff;
        }

        .playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 8px;
            background: #ff3366;
            z-index: 100;
            cursor: ew-resize;
            transform: translateX(-4px);
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.5);
        }

        .playhead:hover {
            background: #ff6699;
            box-shadow: 0 0 15px rgba(255, 51, 102, 0.8);
        }

        .playhead-handle {
            position: absolute;
            top: -5px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 10px solid #ff3366;
        }

        .note-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 15px;
        }

        .note-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            background: #1a1a2a;
            border-radius: 5px;
            margin-bottom: 5px;
            font-size: 0.85rem;
        }

        .note-item .type {
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.75rem;
            text-transform: uppercase;
        }

        #context-menu {
            display: none;
            position: absolute;
            background: #2a2a3a;
            border: 1px solid #444;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            min-width: 150px;
        }

        #context-menu .menu-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #333;
        }

        #context-menu .menu-item:last-child {
            border-bottom: none;
        }

        #context-menu .menu-item:hover {
            background: #33ccff;
            color: #000;
        }

        .note-item .type.red {
            background: #ff3366;
        }

        .note-item .type.blue {
            background: #33ccff;
            color: #000;
        }

        .note-item .type.hold {
            background: #ff9933;
        }

        .note-item .type.spam {
            background: #ffcc00;
            color: #000;
        }

        .note-item .delete-btn {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            font-size: 1rem;
        }

        .note-item .delete-btn:hover {
            color: #ff3366;
        }

        .help-text {
            font-size: 0.8rem;
            color: #666;
            margin-top: 20px;
            line-height: 1.6;
        }

        .tool-selector {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }

        .tool-btn {
            flex: 1;
            padding: 10px;
            background: #222;
            border: 2px solid transparent;
            border-radius: 5px;
            color: #888;
            cursor: pointer;
            font-size: 0.8rem;
            text-transform: uppercase;
        }

        .tool-btn.active {
            border-color: #ff3366;
            color: #fff;
        }

        .tool-btn.red.active {
            border-color: #ff3366;
            background: rgba(255, 51, 102, 0.2);
        }

        .tool-btn.blue.active {
            border-color: #33ccff;
            background: rgba(51, 204, 255, 0.2);
        }

        .tool-btn.hold.active {
            border-color: #ff9933;
            background: rgba(255, 153, 51, 0.2);
        }

        .tool-btn.spam.active {
            border-color: #ffcc00;
            background: rgba(255, 204, 0, 0.2);
        }
    </style>
</head>

<body>
    <header>
        <div class="logo">Map Editor</div>
        <div class="toolbar">
            <button class="btn secondary" onclick="loadAudio()">Load Audio</button>
            <button class="btn secondary" onclick="saveDraft()">Save Draft</button>
            <button class="btn secondary" onclick="loadDraft()">Load Draft</button>
            <button class="btn secondary" onclick="importMap()">Import Map</button>
            <button class="btn primary" onclick="exportMap()">Export Map</button>
            <div style="width: 20px;"></div>
            <button id="record-btn" class="btn secondary" onclick="toggleRecordMode()">⏺ Record</button>
            <button class="btn secondary" onclick="window.location.href='../index.html'">Back to Game</button>
        </div>
    </header>

    <div class="main-container">
        <div class="sidebar">
            <h3>Song Info</h3>
            <div class="form-group">
                <label>Title</label>
                <input type="text" id="song-title" placeholder="Song Title">
            </div>
            <div class="form-group">
                <label>Artist</label>
                <input type="text" id="song-artist" placeholder="Artist Name">
            </div>
            <div class="form-group">
                <label>Difficulty</label>
                <select id="song-difficulty">
                    <option value="Easy">Easy</option>
                    <option value="Normal" selected>Normal</option>
                    <option value="Hard">Hard</option>
                    <option value="Expert">Expert</option>
                </select>
            </div>
            <div class="form-group">
                <label>Difficulty Level (1-10)</label>
                <input type="number" id="difficulty-level" min="1" max="10" value="3">
            </div>
            <div class="form-group">
                <label>BPM</label>
                <input type="number" id="song-bpm" value="120" min="60" max="300">
            </div>
            <div class="form-group">
                <label>Background Image</label>
                <button class="btn secondary" style="width: 100%; padding: 8px;" onclick="loadBackground()">Load
                    Background</button>
                <span id="bg-filename" style="font-size: 0.75rem; color: #666; margin-top: 5px; display: block;">No
                    background</span>
            </div>

            <h3>Note Tool</h3>
            <div class="tool-selector">
                <button class="tool-btn red active" data-type="red" onclick="selectTool('red')">Red</button>
                <button class="tool-btn blue" data-type="blue" onclick="selectTool('blue')">Blue</button>
                <button class="tool-btn hold" data-type="hold" onclick="selectTool('hold')">Hold</button>
                <button class="tool-btn spam" data-type="spam" onclick="selectTool('spam')">Spam</button>
            </div>

            <div class="form-group" id="hold-duration-group" style="display: none;">
                <label>Hold Duration (ms)</label>
                <input type="number" id="hold-duration" value="1000" min="100">
            </div>

            <div class="form-group" id="spam-count-group" style="display: none;">
                <label>Spam Count Required</label>
                <input type="number" id="spam-count" value="5" min="2" max="20">
            </div>

            <h3>Notes (<span id="note-count">0</span>)</h3>
            <div class="note-list" id="note-list">
                <!-- Notes will be listed here -->
            </div>

            <div class="help-text">
                <strong>Shortcuts:</strong><br>
                Space - Play/Pause<br>
                1-4 - Select Tool / Add Note (recording)<br>
                R - Toggle Record Mode<br>
                Click Timeline - Add Note<br>
                Shift+Click - Multi-select<br>
                Drag Playhead - Seek<br>
                Delete - Remove Selected<br>
                Ctrl+Z/Y - Undo/Redo<br>
                Ctrl+C/V - Copy/Paste<br>
            </div>
        </div>

        <div class="editor-area">
            <div class="preview-canvas-container">
                <canvas id="preview-canvas" width="400" height="300"></canvas>
            </div>

            <div class="timeline-container">
                <div class="timeline-controls">
                    <button class="play-btn" id="play-btn" onclick="togglePlay()">▶</button>
                    <button class="play-btn" id="timeline-record-btn" onclick="toggleRecordMode()" style="color: #ff5555;">●</button>
                    <span class="time-display" id="time-display">0:00.000</span>
                    <div style="width: 1px; height: 30px; background: #333; margin: 0 10px;"></div>
                    <select id="snap-select"
                        style="padding: 5px; background: #222; color: #fff; border: 1px solid #444; border-radius: 4px;">
                        <option value="0">No Snap</option>
                        <option value="1">1/1 Beat</option>
                        <option value="2">1/2 Beat</option>
                        <option value="4" selected>1/4 Beat</option>
                        <option value="8">1/8 Beat</option>
                        <option value="16">1/16 Beat</option>
                    </select>
                    <input type="range" id="zoom-slider" min="1" max="10" value="5" style="width: 100px;">
                    <span style="color: #888; font-size: 0.85rem;">Zoom</span>
                </div>

                <div class="timeline-scroll" id="timeline-scroll">
                    <div id="timeline">
                        <div class="timeline-ruler" id="timeline-ruler"></div>
                        <div class="timeline-tracks">
                            <div class="track red">
                                <span class="track-label">Red</span>
                            </div>
                            <div class="track blue">
                                <span class="track-label">Blue</span>
                            </div>
                            <div class="track special">
                                <span class="track-label">Hold/Spam</span>
                            </div>
                        </div>
                        <div class="playhead" id="playhead" style="left: 0;">
                            <div class="playhead-handle"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="audio-input" accept="audio/*" style="display: none;">
    <input type="file" id="map-input" accept=".json" style="display: none;">
    <input type="file" id="bg-input" accept="image/*" style="display: none;">

    <div id="context-menu">
        <div class="menu-item" onclick="deleteSelectedNotes(); hideContextMenu()">Delete</div>
        <div class="menu-item" onclick="copySelectedNotes(); hideContextMenu()">Copy</div>
        <div class="menu-item" onclick="pasteNotes(); hideContextMenu()">Paste</div>
        <div class="menu-item" onclick="toggleNoteType(); hideContextMenu()">Switch Type</div>
    </div>

    <script>
        // ===== STATE =====
        let notes = [];
        let selectedNotes = new Set(); // Changed to Set for multi-select
        let copiedNotes = []; // Clipboard
        let currentTool = 'red';
        let audio = null;
        let isPlaying = false;
        let zoomLevel = 5;
        let pixelsPerMs = 0.1;
        let backgroundImage = null;
        let backgroundFilename = '';
        let isDraggingPlayhead = false;
        let isDraggingNote = false;
        let isResizingHold = false;
        let wasDragging = false;
        let draggedNoteIndex = -1;
        let resizingNoteIndex = -1; // New tracker for resizing

        let isRecording = false;
        let recordingKeys = {};

        // Undo/Redo State
        const historyStack = [];
        const redoStack = [];
        const MAX_HISTORY = 50;

        // Context Menu Helper
        function hideContextMenu() {
            const menu = document.getElementById('context-menu');
            if (menu) menu.style.display = 'none';
        }

        function saveState() {
            // Deep copy notes to history
            const state = JSON.stringify(notes);
            historyStack.push(state);
            if (historyStack.length > MAX_HISTORY) historyStack.shift();
            redoStack.length = 0; // Clear redo stack on new action
            console.log('State Saved', historyStack.length);
        }

        function undo() {
            if (historyStack.length === 0) return;
            const currentState = JSON.stringify(notes);
            redoStack.push(currentState);

            const prevState = historyStack.pop();
            notes = JSON.parse(prevState);

            // Restore selection? verifying if indices match is hard if notes changed order.
            // For now clear selection to be safe.
            selectedNotes.clear();

            updateTimeline();
            drawPreview();
            console.log('Undo performed');
        }

        function redo() {
            if (redoStack.length === 0) return;
            const currentState = JSON.stringify(notes);
            historyStack.push(currentState);

            const nextState = redoStack.pop();
            notes = JSON.parse(nextState);

            selectedNotes.clear();
            updateTimeline();
            drawPreview();
            console.log('Redo performed');
        }

        const previewCanvas = document.getElementById('preview-canvas');
        const previewCtx = previewCanvas.getContext('2d');

        // ===== INITIALIZATION =====
        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            updateTimeline();
            drawPreview();

            // Hide context menu on click elsewhere
            document.addEventListener('click', () => {
                hideContextMenu();
            });

            // Fix sticking drag by ensuring mouseup on window clears everything
            window.addEventListener('mouseup', handleGlobalMouseUp);
        });

        function setupEventListeners() {
            // Audio file input
            document.getElementById('audio-input').addEventListener('change', handleAudioLoad);
            document.getElementById('map-input').addEventListener('change', handleMapImport);
            document.getElementById('bg-input').addEventListener('change', handleBackgroundLoad);

            // Zoom slider
            document.getElementById('zoom-slider').addEventListener('input', (e) => {
                zoomLevel = parseInt(e.target.value);
                pixelsPerMs = 0.05 * zoomLevel;
                updateTimeline();
            });

            // Timeline click to add notes
            document.getElementById('timeline').addEventListener('click', handleTimelineClick);

            // Timeline Right-Click (Context Menu)
            document.getElementById('timeline').addEventListener('contextmenu', (e) => {
                e.preventDefault();
                const menu = document.getElementById('context-menu');
                menu.style.display = 'block';
                menu.style.left = `${e.pageX}px`;
                menu.style.top = `${e.pageY}px`;
            });

            // Scroll Wheel & Zoom
            document.getElementById('timeline-scroll').addEventListener('wheel', (e) => {
                e.preventDefault();
                if (e.ctrlKey) {
                    // Zoom
                    const zoomChange = e.deltaY > 0 ? -1 : 1;
                    let newZoom = zoomLevel + zoomChange;
                    newZoom = Math.max(1, Math.min(20, newZoom)); // Clamp 1-20
                    if (newZoom !== zoomLevel) {
                        zoomLevel = newZoom;
                        pixelsPerMs = 0.05 * zoomLevel;
                        document.getElementById('zoom-slider').value = zoomLevel;
                        updateTimeline();
                    }
                } else {
                    // Scroll
                    const scroll = document.getElementById('timeline-scroll');
                    scroll.scrollLeft += e.deltaY;
                }
            }, { passive: false });

            // Keyboard shortcuts
            document.addEventListener('keydown', handleKeyboard);

            // Playhead dragging
            const playhead = document.getElementById('playhead');
            playhead.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                isDraggingPlayhead = true;
                document.body.style.cursor = 'ew-resize';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDraggingPlayhead && !isDraggingNote && !isResizingHold) return;

                const timelineScroll = document.getElementById('timeline-scroll');
                const timeline = document.getElementById('timeline');
                const rect = timeline.getBoundingClientRect();
                const x = e.clientX - rect.left + timelineScroll.scrollLeft;
                const newTime = Math.max(0, x / pixelsPerMs);

                // Update ALL selected notes if dragging one of them
                if (isDraggingNote && draggedNoteIndex !== -1 && selectedNotes.has(draggedNoteIndex)) {
                    const originalTime = notes[draggedNoteIndex].time;
                    // Only calculate delta for the main dragged note? 
                    // Wait, logic in mousemove handles absolute position.
                    // Multi-drag needs logic update in mousemove.
                }

                if (audio && audio.duration) {
                    const clampedTime = Math.min(newTime, audio.duration * 1000);
                    audio.currentTime = clampedTime / 1000;
                }

                // Update playhead position manually while dragging
                playhead.style.left = `${x}px`;
            });

            // Replaced by global handler
            // document.addEventListener('mouseup', () => { ... });
        } // End setupEventListeners()

        function handleGlobalMouseUp(e) {
            if (e.button === 2) return; // Ignore right click

            // Save state if we finished a drag operation that changed things
            if ((isDraggingNote && draggedNoteIndex !== -1) || (isResizingHold && resizingNoteIndex !== -1)) {
                // State already saved on mousedown
            }

            if (isDraggingPlayhead || isDraggingNote || isResizingHold) {
                wasDragging = true;
                setTimeout(() => wasDragging = false, 50);
            }

            if (isDraggingPlayhead) {
                isDraggingPlayhead = false;
                document.body.style.cursor = '';
            }
            if (isDraggingNote) {
                isDraggingNote = false;
                draggedNoteIndex = -1;
                document.body.style.cursor = '';
                notes.sort((a, b) => a.time - b.time);
                updateTimeline();
            }
            if (isResizingHold) {
                isResizingHold = false;
                resizingNoteIndex = -1;
                document.body.style.cursor = '';
                updateTimeline();
            }
        }

        document.addEventListener('mousemove', (e) => {
            // Note Dragging Logic
            if (isDraggingNote && draggedNoteIndex !== -1) {
                const timeline = document.getElementById('timeline');
                const scroll = document.getElementById('timeline-scroll');
                const rect = timeline.getBoundingClientRect();
                const x = e.clientX - rect.left + scroll.scrollLeft;
                let time = Math.max(0, x / pixelsPerMs);

                // Snap Logic
                const snapDivisor = parseInt(document.getElementById('snap-select').value);
                if (snapDivisor > 0) {
                    const bpm = parseInt(document.getElementById('song-bpm').value) || 120;
                    const msPerBeat = 60000 / bpm;
                    const msPerSnap = msPerBeat / (snapDivisor / 1);
                    time = Math.round(time / msPerSnap) * msPerSnap;
                } else {
                    time = Math.round(time);
                }

                // Calculate delta for multi-select
                const originalTime = notes[draggedNoteIndex].time;
                const delta = time - originalTime;

                // Update Data
                notes[draggedNoteIndex].time = time;
                if (notes[draggedNoteIndex].endTime) {
                    const duration = notes[draggedNoteIndex].endTime - originalTime;
                    notes[draggedNoteIndex].endTime = time + duration;
                }

                // Update DOM directly (Performant & fixes sticking)
                const marker = document.querySelector(`.note-marker[data-index="${draggedNoteIndex}"]`);
                if (marker) {
                    marker.style.left = `${time * pixelsPerMs}px`;

                    // Update hold trail if exists
                    if (notes[draggedNoteIndex].type === 'hold') {
                        // Find the trail in the same track container? 
                        // It's safer to find by structure if we don't have IDs.
                        // Holding track is index 2.
                        // Actually, let's just use updateTimeline ONLY if we really have to, 
                        // OR (better) just rely on the note marker moving for now, 
                        // and update trail on mouseup. 
                        // But user wants to see it move.
                        // Let's try to update trail too.
                        // The hold-trail is a sibling or near the marker? 
                        // In renderNotes: track.appendChild(marker); track.appendChild(trail);
                        // They are not parent/child.
                        // This makes easy toggle hard.
                        // FALLBACK: If it's a hold note, we might NEED to re-render OR do expensive DOM search.
                        // For now, let's just move the marker. The trail update on mouseup is acceptable 
                        // vs the "glued" bug.
                        // OR we can find sibling hold-trail with matching left/width? Hard/Fragile.
                    }
                }

                // Multi-select move
                if (selectedNotes.has(draggedNoteIndex) && selectedNotes.size > 1) {
                    selectedNotes.forEach(idx => {
                        if (idx !== draggedNoteIndex) {
                            notes[idx].time += delta;
                            if (notes[idx].endTime) notes[idx].endTime += delta;

                            const m = document.querySelector(`.note-marker[data-index="${idx}"]`);
                            if (m) m.style.left = `${notes[idx].time * pixelsPerMs}px`;
                        }
                    });
                }

                // drawPreview(time); // Optional: might be heavy?
            }

            // Hold Resizing Logic
            if (isResizingHold && resizingNoteIndex !== -1) {
                const timeline = document.getElementById('timeline');
                const scroll = document.getElementById('timeline-scroll');
                const rect = timeline.getBoundingClientRect();
                const x = e.clientX - rect.left + scroll.scrollLeft;
                let time = Math.max(0, x / pixelsPerMs);

                // Snap Logic 
                const snapDivisor = parseInt(document.getElementById('snap-select').value);
                if (snapDivisor > 0) {
                    const bpm = parseInt(document.getElementById('song-bpm').value) || 120;
                    const msPerBeat = 60000 / bpm;
                    const msPerSnap = msPerBeat / (snapDivisor / 1);
                    time = Math.round(time / msPerSnap) * msPerSnap;
                }

                // Enforce start time < end time
                const startTime = notes[resizingNoteIndex].time;
                if (time > startTime) {
                    notes[resizingNoteIndex].endTime = time;
                    updateTimeline(); // We use updateTimeline for resize as it simplifies UI update (handle pos etc)
                    drawPreview(startTime);
                }
            }
        });


        // Playback update using requestAnimationFrame for better performance
        function playbackLoop() {
            updatePlayback();
            requestAnimationFrame(playbackLoop);
        }
        requestAnimationFrame(playbackLoop);

        // ===== TOOL SELECTION =====
        function selectTool(type) {
            currentTool = type;
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.type === type);
            });

            // Show/hide relevant options
            document.getElementById('hold-duration-group').style.display = type === 'hold' ? 'block' : 'none';
            document.getElementById('spam-count-group').style.display = type === 'spam' ? 'block' : 'none';
        }

        // ===== AUDIO =====
        function loadAudio() {
            document.getElementById('audio-input').click();
        }

        function handleAudioLoad(e) {
            const file = e.target.files[0];
            if (!file) return;

            const url = URL.createObjectURL(file);
            audio = new Audio(url);
            audio.addEventListener('loadedmetadata', () => {
                updateTimeline();
            });
            audio.addEventListener('ended', () => {
                isPlaying = false;
                document.getElementById('play-btn').textContent = '▶';
            });
        }

        function togglePlay() {
            if (!audio) {
                alert('Please load an audio file first');
                return;
            }

            if (isPlaying) {
                audio.pause();
                isPlaying = false;
                document.getElementById('play-btn').textContent = '▶';
            } else {
                audio.play();
                isPlaying = true;
                document.getElementById('play-btn').textContent = '⏸';
            }
        }

        // ===== BACKGROUND =====
        function loadBackground() {
            document.getElementById('bg-input').click();
        }

        function handleBackgroundLoad(e) {
            const file = e.target.files[0];
            if (!file) return;

            backgroundFilename = file.name;
            document.getElementById('bg-filename').textContent = backgroundFilename;

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    backgroundImage = img;
                    drawPreview();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function updatePlayback() {
            if (!audio) return;
            if (isDraggingPlayhead) return; // Don't update while dragging

            const currentTime = audio.currentTime * 1000;
            const playhead = document.getElementById('playhead');
            playhead.style.left = `${currentTime * pixelsPerMs}px`;

            // Update time display
            const mins = Math.floor(audio.currentTime / 60);
            const secs = Math.floor(audio.currentTime % 60);
            const ms = Math.floor((audio.currentTime % 1) * 1000);
            document.getElementById('time-display').textContent =
                `${mins}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;

            // Auto-scroll timeline
            if (isPlaying) {
                const scroll = document.getElementById('timeline-scroll');
                const playheadX = currentTime * pixelsPerMs;
                const viewportWidth = scroll.clientWidth;
                if (playheadX > scroll.scrollLeft + viewportWidth - 100) {
                    scroll.scrollLeft = playheadX - 100;
                }
            }

            drawPreview(currentTime);
        }

        // ===== TIMELINE =====
        function updateTimeline() {
            const timeline = document.getElementById('timeline');
            const ruler = document.getElementById('timeline-ruler');

            // Calculate timeline width
            const duration = audio ? audio.duration * 1000 : 60000;
            const width = duration * pixelsPerMs;
            timeline.style.width = `${Math.max(width, window.innerWidth)}px`;

            // Draw ruler
            ruler.innerHTML = '';
            const beatInterval = 60000 / (parseInt(document.getElementById('song-bpm').value) || 120);

            for (let t = 0; t < duration; t += beatInterval) {
                const marker = document.createElement('div');
                marker.style.cssText = `
                    position: absolute;
                    left: ${t * pixelsPerMs}px;
                    top: 0;
                    height: 100%;
                    width: 1px;
                    background: ${t % (beatInterval * 4) === 0 ? '#555' : '#333'};
                `;
                ruler.appendChild(marker);

                // Time labels every 4 beats
                if (t % (beatInterval * 4) === 0) {
                    const label = document.createElement('span');
                    label.style.cssText = `
                        position: absolute;
                        left: ${t * pixelsPerMs + 5}px;
                        top: 5px;
                        font-size: 10px;
                        color: #666;
                    `;
                    label.textContent = `${Math.floor(t / 1000)}s`;
                    ruler.appendChild(label);
                }
            }

            // Render notes
            renderNotes();
        }

        function renderNotes() {
            // Clear existing note markers
            document.querySelectorAll('.note-marker, .hold-trail').forEach(el => el.remove());

            const tracks = document.querySelector('.timeline-tracks');

            notes.forEach((note, index) => {
                const marker = document.createElement('div');
                marker.className = `note-marker ${note.type}`;
                marker.style.left = `${note.time * pixelsPerMs}px`;
                marker.dataset.index = index;
                if (selectedNotes.has(index)) marker.classList.add('selected');

                marker.onmousedown = (e) => {
                    e.stopPropagation();

                    // Multi-select Logic
                    if (e.shiftKey) {
                        if (selectedNotes.has(index)) {
                            selectedNotes.delete(index);
                        } else {
                            selectedNotes.add(index);
                        }
                    } else if (!selectedNotes.has(index)) {
                        selectedNotes.clear();
                        selectedNotes.add(index);
                    }

                    saveState(); // Save before drag starts
                    startDragNote(index, e);
                    updateTimeline(); // Refresh selection visuals
                };

                // Determine track
                let trackIndex = 0;
                if (note.type === 'blue') trackIndex = 1;
                if (note.type === 'hold' || note.type === 'spam') trackIndex = 2;

                const track = tracks.children[trackIndex];
                track.appendChild(marker);

                // Hold trail
                if (note.type === 'hold' && note.endTime) {
                    const trail = document.createElement('div');
                    trail.className = 'hold-trail';
                    trail.style.left = `${note.time * pixelsPerMs}px`;
                    trail.style.width = `${(note.endTime - note.time) * pixelsPerMs}px`;

                    // Resize Handle
                    const handle = document.createElement('div');
                    handle.className = 'hold-resize-handle';
                    handle.onmousedown = (e) => {
                        e.stopPropagation();
                        saveState(); // Save before resize
                        isResizingHold = true;
                        resizingNoteIndex = index;
                        document.body.style.cursor = 'e-resize';
                    };
                    trail.appendChild(handle);

                    track.appendChild(trail);
                }
            }); // This closes the forEach loop

            // Update note list
            updateNoteList();
        }

        function handleTimelineClick(e) {
            // Prevent placing note if dragging something or just finished dragging
            if (isDraggingPlayhead || isDraggingNote || wasDragging) return;
            // Also prevent if clicking a note marker (handled by note click/drag)
            if (e.target.classList.contains('note-marker')) return;
            // Prevent if clicking on hold trail or resize handle
            if (e.target.classList.contains('hold-trail') || e.target.classList.contains('hold-resize-handle')) return;

            // Clear selection when clicking on empty timeline space
            selectedNotes.clear();

            const timeline = document.getElementById('timeline');
            const rect = timeline.getBoundingClientRect();
            const x = e.clientX - rect.left + document.getElementById('timeline-scroll').scrollLeft;
            let time = x / pixelsPerMs;

            // SNAP LOGIC
            const snapDivisor = parseInt(document.getElementById('snap-select').value);
            if (snapDivisor > 0) {
                const bpm = parseInt(document.getElementById('song-bpm').value) || 120;
                const msPerBeat = 60000 / bpm;
                const msPerSnap = msPerBeat / (snapDivisor / 1); // e.g. 1/4 beat

                time = Math.round(time / msPerSnap) * msPerSnap;
            } else {
                time = Math.round(time);
            }

            addNote(time);
        }

        // ===== NOTE MANAGEMENT =====
        function addNoteAtCurrentTime(type) {
            if (!audio) return;
            // Use current tool settings but override type
            const savedTool = currentTool;
            currentTool = type;

            // Calculate time
            let time = audio.currentTime * 1000;

            // Optional: Quantize if snap is on
            const snapDivisor = parseInt(document.getElementById('snap-select').value);
            if (snapDivisor > 0) {
                const bpm = parseInt(document.getElementById('song-bpm').value) || 120;
                const msPerBeat = 60000 / bpm;
                const msPerSnap = msPerBeat / (snapDivisor / 1);
                time = Math.round(time / msPerSnap) * msPerSnap;
            }

            addNote(time);

            currentTool = savedTool; // Restore tool
        }

        function addNote(time) {
            saveState(); // Save before adding

            const note = {
                time: time,
                type: currentTool
            };

            if (currentTool === 'hold') {
                const duration = parseInt(document.getElementById('hold-duration').value) || 1000;
                // Snap duration too if snapping is enabled? Maybe just start time for now.
                note.endTime = time + duration;
            }

            if (currentTool === 'spam') {
                note.spamRequired = parseInt(document.getElementById('spam-count').value) || 5;
            }

            notes.push(note);
            notes.sort((a, b) => a.time - b.time);

            updateTimeline();
            drawPreview(time); // Show preview at note time
        }

        function selectNote(index) {
            selectedNote = null; // Clear single selection
            selectedNotes.clear(); // Clear multi-selection
            selectedNotes.add(index); // Add this one
            document.querySelectorAll('.note-marker').forEach(m => m.classList.remove('selected'));
            document.querySelector(`.note-marker[data-index="${index}"]`)?.classList.add('selected');
        }

        function startDragNote(index, e) {
            isDraggingNote = true;
            draggedNoteIndex = index;
            document.body.style.cursor = 'grabbing';
        }

        function deleteNote(index) {
            saveState(); // Save before deleting
            notes.splice(index, 1);
            selectedNotes.clear(); // Clear selection after delete
            updateTimeline();
            drawPreview();
        }

        function updateNoteList() {
            const list = document.getElementById('note-list');
            document.getElementById('note-count').textContent = notes.length;

            list.innerHTML = notes.map((note, i) => `
                <div class="note-item" onclick="selectNote(${i})">
                    <span class="type ${note.type}">${note.type}</span>
                    <span>${(note.time / 1000).toFixed(2)}s${note.endTime ? ' (' + ((note.endTime - note.time) / 1000).toFixed(2) + 's)' : ''}</span>
                    <button class="delete-btn" onclick="event.stopPropagation(); deleteNote(${i})">×</button>
                </div>
            `).join('');
        }

        // ===== PREVIEW =====
        function drawPreview(currentTime = 0) {
            const ctx = previewCtx;
            const w = previewCanvas.width;
            const h = previewCanvas.height;
            const cx = w / 2;
            const cy = h / 2;

            // Clear / Draw background
            if (backgroundImage) {
                // Draw background image (cover style)
                const imgRatio = backgroundImage.width / backgroundImage.height;
                const canvasRatio = w / h;
                let drawW, drawH, drawX, drawY;

                if (imgRatio > canvasRatio) {
                    drawH = h;
                    drawW = h * imgRatio;
                    drawX = (w - drawW) / 2;
                    drawY = 0;
                } else {
                    drawW = w;
                    drawH = w / imgRatio;
                    drawX = 0;
                    drawY = (h - drawH) / 2;
                }

                ctx.drawImage(backgroundImage, drawX, drawY, drawW, drawH);
                // Add dark overlay for visibility
                ctx.fillStyle = 'rgba(10, 10, 26, 0.7)';
                ctx.fillRect(0, 0, w, h);
            } else {
                ctx.fillStyle = '#0a0a1a';
                ctx.fillRect(0, 0, w, h);
            }

            // Draw center ring (Hit Area)
            const ringRadius = 60; // Editor scale
            // Hit Area (Black Circle)
            ctx.beginPath();
            ctx.arc(cx, cy, ringRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#000000';
            ctx.fill();

            // Ring border
            ctx.beginPath();
            ctx.arc(cx, cy, ringRadius, 0, Math.PI * 2);
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw notes
            const approachTime = 1500;
            const spawnRadius = 150;
            const NOTE_SPAWN_RADIUS = 150;
            const RING_RADIUS = 60;

            notes.forEach(note => {
                const timeUntil = note.time - currentTime;
                const isHoldDuration = note.type === 'hold' && note.endTime && currentTime >= note.time && currentTime <= note.endTime;

                if (timeUntil > approachTime || (timeUntil < -100 && !isHoldDuration)) return;

                // Color Selection
                let color = '#33ccff'; // Blue default
                if (note.type === 'red') color = '#ff3366';
                if (note.type === 'hold') color = '#ffcc00';
                if (note.type === 'spam') color = '#33ff66';

                // Radius logic
                let startRadius, endRadius;
                const progressStart = 1 - (timeUntil / approachTime);
                startRadius = RING_RADIUS + (NOTE_SPAWN_RADIUS - RING_RADIUS) * (1 - progressStart);

                if (note.type === 'hold' && note.endTime) {
                    const timeUntilEnd = note.endTime - currentTime;
                    const progressEnd = 1 - (timeUntilEnd / approachTime);
                    endRadius = RING_RADIUS + (NOTE_SPAWN_RADIUS - RING_RADIUS) * (1 - progressEnd);

                    // Clamping
                    if (startRadius < 0) startRadius = 0;
                    if (endRadius > NOTE_SPAWN_RADIUS) endRadius = NOTE_SPAWN_RADIUS;

                    // Draw Hold Duration as a thick band
                    ctx.beginPath();
                    ctx.arc(cx, cy, (startRadius + endRadius) / 2, 0, Math.PI * 2);
                    ctx.strokeStyle = color;
                    ctx.lineWidth = Math.abs(endRadius - startRadius);
                    ctx.globalAlpha = 0.4;
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;

                    // Draw edges for clarity
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(cx, cy, startRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(cx, cy, endRadius, 0, Math.PI * 2);
                    ctx.stroke();
                } else {
                    if (startRadius < 0) return;
                    ctx.beginPath();
                    ctx.arc(cx, cy, startRadius, 0, Math.PI * 2);
                    ctx.strokeStyle = color;
                    ctx.lineWidth = (note.type === 'spam') ? 2 : 4;
                    if (note.type === 'spam') ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            });
        }

        // ===== KEYBOARD =====
        function handleKeyboard(e) {
            if (e.target.tagName === 'INPUT') return;

            switch (e.code) {
                case 'Space':
                    e.preventDefault();
                    togglePlay();
                    break;
                case 'KeyR':
                    e.preventDefault();
                    toggleRecordMode();
                    break;
                case 'Digit1':
                    if (isRecording && isPlaying) { addNoteAtCurrentTime('red'); }
                    else { selectTool('red'); }
                    break;
                case 'Digit2':
                    if (isRecording && isPlaying) { addNoteAtCurrentTime('blue'); }
                    else { selectTool('blue'); }
                    break;
                case 'Digit3':
                    if (isRecording && isPlaying) { addNoteAtCurrentTime('hold'); }
                    else { selectTool('hold'); }
                    break;
                case 'Digit4':
                    if (isRecording && isPlaying) { addNoteAtCurrentTime('spam'); }
                    else { selectTool('spam'); }
                    break;
                case 'Delete':
                case 'Backspace':
                    if (selectedNotes.size > 0) {
                        deleteSelectedNotes();
                    }
                    break;
            }
        }

        // ===== IMPORT/EXPORT =====
        function importMap() {
            document.getElementById('map-input').click();
        }

        function handleMapImport(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);

                    document.getElementById('song-title').value = data.title || '';
                    document.getElementById('song-artist').value = data.artist || '';
                    document.getElementById('song-difficulty').value = data.difficulty || 'Normal';
                    document.getElementById('difficulty-level').value = data.difficultyLevel || 3;
                    document.getElementById('song-bpm').value = data.bpm || 120;

                    notes = data.notes || [];
                    updateTimeline();
                    drawPreview();

                    alert('Map imported successfully!');
                } catch (err) {
                    alert('Failed to parse map file');
                }
            };
            reader.readAsText(file);
        }

        function exportMap() {
            const mapData = {
                title: document.getElementById('song-title').value || 'Untitled',
                artist: document.getElementById('song-artist').value || 'Unknown',
                difficulty: document.getElementById('song-difficulty').value,
                difficultyLevel: parseInt(document.getElementById('difficulty-level').value) || 3,
                bpm: parseInt(document.getElementById('song-bpm').value) || 120,
                audioFile: 'song.mp3',
                backgroundFile: backgroundFilename || null,
                previewTime: 0,
                notes: notes
            };

            const json = JSON.stringify(mapData, null, 4);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'map.json';
            a.click();

            URL.revokeObjectURL(url);
        }

        // ===== LIVE RECORDING =====
        function toggleRecordMode() {
            isRecording = !isRecording;
            
            // Update header record button
            const headerBtn = document.getElementById('record-btn');
            if (headerBtn) {
                if (isRecording) {
                    headerBtn.style.background = '#ff3366';
                    headerBtn.style.color = '#fff';
                    headerBtn.textContent = '⏺ Recording...';
                } else {
                    headerBtn.style.background = '';
                    headerBtn.style.color = '';
                    headerBtn.textContent = '⏺ Record';
                }
            }
            
            // Update timeline record button
            const timelineBtn = document.getElementById('timeline-record-btn');
            if (timelineBtn) {
                if (isRecording) {
                    timelineBtn.style.background = '#aa0000';
                    timelineBtn.style.color = 'white';
                } else {
                    timelineBtn.style.background = '';
                    timelineBtn.style.color = '#ff5555';
                }
            }
            
            // Auto-start playback when recording starts
            if (isRecording && !isPlaying && audio) {
                togglePlay();
            }
        }

        // Live recording keydown handler - stores key press start times
        function handleRecordingKeyDown(e) {
            if (!isRecording || !isPlaying || !audio) return;
            if (e.target.tagName === 'INPUT') return;
            
            // Ignore if key currently held
            if (recordingKeys[e.code]) return;
            
            // Record the start time for this key
            recordingKeys[e.code] = audio.currentTime * 1000;
        }

        // Add recording keydown listener
        document.addEventListener('keydown', handleRecordingKeyDown);

        document.addEventListener('keyup', (e) => {
            if (isRecording && isPlaying && audio && recordingKeys[e.code]) {
                const startTime = recordingKeys[e.code];
                const endTime = audio.currentTime * 1000;
                const duration = endTime - startTime;

                delete recordingKeys[e.code];

                // Determine Input Type based on key? 
                // For simplicity, let's say: Z/X = Red/Blue? Or just use current tool?
                // User said "if i hold it adds hold note".

                let type = currentTool;
                if (type === 'hold' || type === 'spam') type = 'blue'; // Default to normal note color unless explicit

                // Check duration for Auto-Hold
                let finalNote = {
                    time: startTime,
                    type: type,
                    angle: 0
                };

                if (duration > 200) { // If held for more than 200ms, make it a hold note
                    finalNote.type = 'hold';
                    finalNote.endTime = endTime;
                }

                // Apply Snapping?
                // Probably better to record raw, but user asked for Play Placement.
                // Let's add option or just raw. Most rhythm game editors use snapping or partial snapping.
                // Let's snap the START time to nearest 1/16 or current snap setting?

                const snapDivisor = parseInt(document.getElementById('snap-select').value);
                if (snapDivisor > 0) {
                    const bpm = parseInt(document.getElementById('song-bpm').value) || 120;
                    const msPerBeat = 60000 / bpm;
                    const msPerSnap = msPerBeat / (snapDivisor / 1);
                    finalNote.time = Math.round(finalNote.time / msPerSnap) * msPerSnap;
                    if (finalNote.endTime) {
                        finalNote.endTime = Math.round(finalNote.endTime / msPerSnap) * msPerSnap;
                    }
                }

                saveState(); // Save before adding recorded note
                notes.push(finalNote);
                notes.sort((a, b) => a.time - b.time);
                updateTimeline();
                drawPreview(finalNote.time);
            }
        });

        // ===== LOCAL DRAFTS =====
        function saveDraft() {
            const mapData = {
                title: document.getElementById('song-title').value,
                artist: document.getElementById('song-artist').value,
                difficulty: document.getElementById('song-difficulty').value,
                difficultyLevel: document.getElementById('difficulty-level').value,
                bpm: document.getElementById('song-bpm').value,
                notes: notes,
                backgroundFilename: backgroundFilename
            };
            localStorage.setItem('rhythm_circle_draft', JSON.stringify(mapData));
            alert('Draft saved to browser!');
        }

        function loadDraft() {
            const draft = localStorage.getItem('rhythm_circle_draft');
            if (!draft) {
                alert('No draft found in this browser.');
                return;
            }
            try {
                const data = JSON.parse(draft);
                document.getElementById('song-title').value = data.title || '';
                document.getElementById('song-artist').value = data.artist || '';
                document.getElementById('song-difficulty').value = data.difficulty || 'Normal';
                document.getElementById('difficulty-level').value = data.difficultyLevel || 3;
                document.getElementById('song-bpm').value = data.bpm || 120;
                notes = data.notes || [];
                backgroundFilename = data.backgroundFilename || '';
                document.getElementById('bg-filename').textContent = backgroundFilename || 'No background';
                updateTimeline();
                drawPreview();
                alert('Draft loaded successfully!');
            } catch (e) {
                alert('Failed to load draft.');
            }
        }

        // ===== CONTEXT MENU & SHORTCUTS =====
        function deleteSelectedNotes() {
            hideContextMenu();
            if (selectedNotes.size === 0) return;
            saveState(); // Save before delete
            // Filter out selected notes
            notes = notes.filter((_, index) => !selectedNotes.has(index));
            selectedNotes.clear();
            updateTimeline();
        }

        function copySelectedNotes() {
            hideContextMenu();
            copiedNotes = notes.filter((_, index) => selectedNotes.has(index)).map(n => ({ ...n })); // Deep copy
        }

        function pasteNotes() {
            hideContextMenu();
            if (copiedNotes.length === 0) return;
            saveState(); // Save before paste
            // Paste at current playhead or just offset?
            // Let's offset by 1 beat (500ms approx)
            const offset = 500;
            copiedNotes.forEach(note => {
                const newNote = { ...note };
                newNote.time += offset;
                if (newNote.endTime) newNote.endTime += offset;
                notes.push(newNote);
            });
            notes.sort((a, b) => a.time - b.time);
            updateTimeline();
        }

        function toggleNoteType() {
            hideContextMenu();
            saveState(); // Save before type change
            selectedNotes.forEach(index => {
                const note = notes[index];
                if (note.type === 'red') note.type = 'blue';
                else if (note.type === 'blue') note.type = 'hold';
                else if (note.type === 'hold') note.type = 'spam';
                else note.type = 'red';

                // Add/Remove endTime if switching to/from hold
                if (note.type === 'hold' && !note.endTime) note.endTime = note.time + 1000;
                if (note.type !== 'hold') delete note.endTime;
            });
            updateTimeline();
        }

        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT') return; // Ignore if typing in input

            if (e.key === 'Delete' || e.key === 'Backspace') {
                deleteSelectedNotes();
            }
            if (e.ctrlKey && e.code === 'KeyC') {
                copySelectedNotes();
            }
            if (e.ctrlKey && e.code === 'KeyV') {
                pasteNotes();
            }
            if (e.ctrlKey && e.code === 'KeyZ') {
                e.preventDefault();
                undo();
            }
            if (e.ctrlKey && e.code === 'KeyY') {
                e.preventDefault();
                redo();
            }
        });
    </script>
</body>

</html>