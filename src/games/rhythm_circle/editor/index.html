<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rhythm Circle - Map Editor</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@400;500;700&display=swap"
        rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: #0a0a1a;
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            user-select: none;
            /* Make whole editor non-selective */
        }

        header {
            background: #111;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #333;
        }

        .logo {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            color: #ff3366;
        }

        .toolbar {
            display: flex;
            gap: 10px;
        }

        .btn {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.85rem;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn.primary {
            background: #ff3366;
            color: #fff;
        }

        .btn.primary:hover {
            background: #ff4477;
        }

        .btn.secondary {
            background: #333;
            color: #ccc;
        }

        .btn.secondary:hover {
            background: #444;
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 300px;
            background: #111;
            border-right: 1px solid #333;
            padding: 20px;
            overflow-y: auto;
        }

        .sidebar h3 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            color: #ff3366;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            font-size: 0.85rem;
            color: #888;
            margin-bottom: 5px;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px;
            background: #1a1a2a;
            border: 1px solid #333;
            border-radius: 5px;
            color: #fff;
            font-family: inherit;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #ff3366;
        }

        .editor-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .preview-canvas-container {
            height: 300px;
            background: #0a0a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            border-bottom: 1px solid #333;
        }

        #preview-canvas {
            max-width: 100%;
            max-height: 100%;
        }

        .timeline-container {
            flex: 1;
            background: #0d0d1d;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .timeline-controls {
            padding: 15px;
            background: #111;
            display: flex;
            align-items: center;
            gap: 15px;
            border-bottom: 1px solid #333;
        }

        .time-display {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            color: #33ccff;
            min-width: 100px;
        }

        .play-btn {
            width: 40px;
            height: 40px;
            background: #ff3366;
            border: none;
            border-radius: 50%;
            color: #fff;
            font-size: 1.2rem;
            cursor: pointer;
        }

        .timeline-scroll {
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
            position: relative;
        }

        #timeline {
            height: 200px;
            min-width: 100%;
            position: relative;
            background: linear-gradient(to right, #0d0d1d, #1a1a2a);
            user-select: none;
            /* Prevent text selection */
        }

        .timeline-ruler {
            position: absolute;
            top: 0;
            left: 0;
            height: 30px;
            width: 100%;
            background: #111;
            border-bottom: 1px solid #333;
            cursor: pointer;
            z-index: 5;
        }

        .timeline-tracks {
            position: absolute;
            top: 30px;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .track {
            height: 40px;
            border-bottom: 1px solid #222;
            position: relative;
        }

        .track.red {
            background: rgba(255, 51, 102, 0.1);
        }

        .track.blue {
            background: rgba(51, 204, 255, 0.1);
        }

        .track.special {
            background: rgba(255, 204, 0, 0.1);
        }

        .track-label {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.75rem;
            color: #666;
            text-transform: uppercase;
        }

        .note-marker {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            border: 2px solid #fff;
        }

        .note-marker.red {
            background: #ff3366;
            top: 50%;
            box-shadow: 0 0 5px #ff3366;
        }

        .note-marker.blue {
            background: #33ccff;
            top: 50%;
            box-shadow: 0 0 5px #33ccff;
        }

        .note-marker.hold {
            background: #ffcc00;
        }

        .note-marker.spam {
            background: #33ff66;
            border-style: dashed;
        }

        .note-marker:hover {
            transform: translate(-50%, -50%) scale(1.2);
        }

        .note-marker.selected {
            box-shadow: 0 0 10px #fff;
        }

        .hold-trail {
            position: absolute;
            height: 10px;
            background: rgba(255, 204, 0, 0.4);
            top: 50%;
            transform: translateY(-50%);
            border-radius: 5px;
        }

        .hold-resize-handle {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 8px;
            background: rgba(255, 255, 255, 0.5);
            cursor: e-resize;
            border-radius: 0 4px 4px 0;
        }

        .hold-resize-handle:hover {
            background: #fff;
        }

        .playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 8px;
            background: #ff3366;
            z-index: 100;
            cursor: ew-resize;
            transform: translateX(-4px);
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.5);
        }

        .playhead:hover {
            background: #ff6699;
            box-shadow: 0 0 15px rgba(255, 51, 102, 0.8);
        }

        .playhead-handle {
            position: absolute;
            top: -5px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 10px solid #ff3366;
        }

        .note-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 15px;
        }

        .note-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            background: #1a1a2a;
            border-radius: 5px;
            margin-bottom: 5px;
            font-size: 0.85rem;
        }

        .note-item .type {
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.75rem;
            text-transform: uppercase;
        }

        #context-menu {
            display: none;
            position: absolute;
            background: #2a2a3a;
            border: 1px solid #444;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            min-width: 150px;
        }

        #context-menu .menu-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #333;
        }

        #context-menu .menu-item:last-child {
            border-bottom: none;
        }

        #context-menu .menu-item:hover {
            background: #33ccff;
            color: #000;
        }

        .note-item .type.red {
            background: #ff3366;
        }

        .note-item .type.blue {
            background: #33ccff;
            color: #000;
        }

        .note-item .type.hold {
            background: #ff9933;
        }

        .note-item .type.spam {
            background: #ffcc00;
            color: #000;
        }

        .note-item .delete-btn {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            font-size: 1rem;
        }

        .note-item .delete-btn:hover {
            color: #ff3366;
        }

        .help-text {
            font-size: 0.8rem;
            color: #666;
            margin-top: 20px;
            line-height: 1.6;
        }

        .tool-selector {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }

        .tool-btn {
            flex: 1;
            padding: 10px;
            background: #222;
            border: 2px solid transparent;
            border-radius: 5px;
            color: #888;
            cursor: pointer;
            font-size: 0.8rem;
            text-transform: uppercase;
        }

        .tool-btn.active {
            border-color: #ff3366;
            color: #fff;
        }

        .tool-btn.red.active {
            border-color: #ff3366;
            background: rgba(255, 51, 102, 0.2);
        }

        .tool-btn.blue.active {
            border-color: #33ccff;
            background: rgba(51, 204, 255, 0.2);
        }

        .tool-btn.hold.active {
            border-color: #ff9933;
            background: rgba(255, 153, 51, 0.2);
        }

        .tool-btn.spam.active {
            border-color: #ffcc00;
            background: rgba(255, 204, 0, 0.2);
        }
    </style>
</head>

<body>
    <header>
        <div class="logo">Map Editor</div>
        <div class="toolbar">
            <button class="btn secondary" onclick="loadAudio()">Load Audio</button>
            <button class="btn secondary" onclick="saveDraft()">Save Draft</button>
            <button class="btn secondary" onclick="loadDraft()">Load Draft</button>
            <button class="btn secondary" onclick="importMap()">Import Map</button>
            <button class="btn primary" onclick="exportMap()">Export Map</button>
            <button class="btn secondary" style="background: #9933ff; color: #fff;" onclick="uploadMap()">Upload
                Cloud</button>
            <button class="btn secondary" style="background: #ffaa00; color: #000;" onclick="autoMap()">✨ Auto
                Map</button>
            <div style="width: 20px;"></div>
            <button id="record-btn" class="btn secondary" onclick="toggleRecordMode()">⏺ Record</button>
            <button id="playtest-btn" class="btn primary" onclick="startPlaytest()" style="background: #33cc66;">▶
                Playtest</button>
            <button class="btn secondary" onclick="window.location.href='../index.html'">Back to Game</button>
        </div>
    </header>

    <div class="main-container">
        <div class="sidebar">
            <h3>Song Info</h3>
            <div class="form-group">
                <label>Title</label>
                <input type="text" id="song-title" placeholder="Song Title">
            </div>
            <div class="form-group">
                <label>Artist</label>
                <input type="text" id="song-artist" placeholder="Artist Name">
            </div>
            <div class="form-group">
                <label>Difficulty</label>
                <select id="song-difficulty">
                    <option value="Easy">Easy</option>
                    <option value="Normal" selected>Normal</option>
                    <option value="Hard">Hard</option>
                    <option value="Expert">Expert</option>
                </select>
            </div>
            <div class="form-group">
                <label>Difficulty Level (1-10)</label>
                <input type="number" id="difficulty-level" min="1" max="10" value="3">
            </div>
            <div class="form-group">
                <label>BPM</label>
                <input type="number" id="song-bpm" value="120" min="60" max="300">
            </div>
            <div class="form-group">
                <label>Background Image</label>
                <button class="btn secondary" style="width: 100%; padding: 8px;" onclick="loadBackground()">Load
                    Background</button>
                <span id="bg-filename" style="font-size: 0.75rem; color: #666; margin-top: 5px; display: block;">No
                    background</span>
            </div>

            <h3>Note Tool</h3>
            <div class="tool-selector">
                <button class="tool-btn red active" data-type="red" onclick="selectTool('red')">Red</button>
                <button class="tool-btn blue" data-type="blue" onclick="selectTool('blue')">Blue</button>
                <button class="tool-btn hold" data-type="hold" onclick="selectTool('hold')">Hold</button>
                <button class="tool-btn spam" data-type="spam" onclick="selectTool('spam')">Spam</button>
            </div>

            <div class="form-group" id="hold-duration-group" style="display: none;">
                <label>Hold Duration (ms)</label>
                <input type="number" id="hold-duration" value="1000" min="100">
            </div>

            <div class="form-group" id="spam-count-group" style="display: none;">
                <label>Spam Count Required</label>
                <input type="number" id="spam-count" value="5" min="2" max="20">
            </div>

            <h3>Notes (<span id="note-count">0</span>)</h3>
            <div class="note-list" id="note-list">
                <!-- Notes will be listed here -->
            </div>

            <div class="help-text">
                <strong>Shortcuts:</strong><br>
                Space - Play/Pause<br>
                1-4 - Select Tool / Add Note (recording)<br>
                R - Toggle Record Mode<br>
                Click Timeline - Add Note<br>
                Shift+Click - Multi-select<br>
                Drag Playhead - Seek<br>
                Delete - Remove Selected<br>
                Ctrl+Z/Y - Undo/Redo<br>
                Ctrl+C/V - Copy/Paste<br>
            </div>
        </div>

        <div class="editor-area">
            <div class="preview-canvas-container">
                <canvas id="preview-canvas" width="400" height="300"></canvas>
            </div>

            <div class="timeline-container">
                <div class="timeline-controls">
                    <button class="play-btn" id="stop-btn" onclick="stopAndReset()"
                        title="Stop and go to start">⏹</button>
                    <button class="play-btn" id="play-btn" onclick="togglePlay()">▶</button>
                    <button class="play-btn" id="timeline-record-btn" onclick="toggleRecordMode()"
                        style="color: #ff5555;">●</button>
                    <span class="time-display" id="time-display">0:00.000</span>
                    <div style="width: 1px; height: 30px; background: #333; margin: 0 10px;"></div>
                    <select id="snap-select"
                        style="padding: 5px; background: #222; color: #fff; border: 1px solid #444; border-radius: 4px;">
                        <option value="0">No Snap</option>
                        <option value="1">1/1 Beat</option>
                        <option value="2">1/2 Beat</option>
                        <option value="4" selected>1/4 Beat</option>
                        <option value="8">1/8 Beat</option>
                        <option value="16">1/16 Beat</option>
                    </select>
                    <input type="range" id="zoom-slider" min="1" max="20" value="5" style="width: 100px;">
                    <span style="color: #888; font-size: 0.85rem;">Zoom</span>
                    <span id="last-saved" style="color: #666; font-size: 0.9em; margin-left: 20px;"></span>
                </div>

                <div class="timeline-scroll" id="timeline-scroll">
                    <div id="timeline">
                        <div class="timeline-ruler" id="timeline-ruler"></div>
                        <div class="timeline-tracks">
                            <div class="track red">
                                <span class="track-label">Red</span>
                            </div>
                            <div class="track blue">
                                <span class="track-label">Blue</span>
                            </div>
                            <div class="track special">
                                <span class="track-label">Hold/Spam</span>
                            </div>
                        </div>
                        <div class="playhead" id="playhead" style="left: 0;">
                            <div class="playhead-handle"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="audio-input" accept="audio/*" style="display: none;">
    <input type="file" id="map-input" accept=".json" style="display: none;">
    <input type="file" id="bg-input" accept="image/*" style="display: none;">

    <div id="context-menu">
        <div class="menu-item" onclick="deleteSelectedNotes(); hideContextMenu()">Delete</div>
        <div class="menu-item" onclick="copySelectedNotes(); hideContextMenu()">Copy</div>
        <div class="menu-item" onclick="pasteNotes(); hideContextMenu()">Paste</div>
        <div class="menu-item" onclick="toggleNoteType(); hideContextMenu()">Switch Type</div>
    </div>

    <!-- Playtest Overlay -->
    <div id="playtest-overlay"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(10, 10, 26, 0.95); z-index: 1000;">
        <canvas id="playtest-canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></canvas>
        <div id="playtest-hud"
            style="position: fixed; top: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 20px; align-items: center; z-index: 1001;">
            <div
                style="background: rgba(0,0,0,0.7); padding: 10px 20px; border-radius: 10px; color: #fff; font-family: 'Orbitron', sans-serif;">
                <span id="playtest-time">0:00</span>
            </div>
        </div>
        <div id="playtest-controls"
            style="position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); display: flex; gap: 15px; z-index: 1001;">
            <button onclick="pausePlaytest()"
                style="padding: 15px 30px; background: #ff9933; color: #000; border: none; border-radius: 8px; font-family: 'Orbitron', sans-serif; font-size: 1rem; cursor: pointer;">⏸
                Pause</button>
            <button onclick="endPlaytest()"
                style="padding: 15px 30px; background: #ff3366; color: #fff; border: none; border-radius: 8px; font-family: 'Orbitron', sans-serif; font-size: 1rem; cursor: pointer;">✕
                Exit</button>
        </div>
        <!-- Pause menu (hidden by default) -->
        <div id="playtest-pause-menu"
            style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(20, 20, 40, 0.95); padding: 40px; border-radius: 15px; border: 2px solid #33ccff; z-index: 1002;">
            <h2 style="color: #33ccff; font-family: 'Orbitron', sans-serif; margin-bottom: 30px; text-align: center;">
                PAUSED</h2>
            <div style="display: flex; flex-direction: column; gap: 15px;">
                <button onclick="resumePlaytest()"
                    style="padding: 15px 40px; background: #33cc66; color: #000; border: none; border-radius: 8px; font-family: 'Orbitron', sans-serif; font-size: 1rem; cursor: pointer;">▶
                    Resume</button>
                <button onclick="restartPlaytest()"
                    style="padding: 15px 40px; background: #33ccff; color: #000; border: none; border-radius: 8px; font-family: 'Orbitron', sans-serif; font-size: 1rem; cursor: pointer;">↺
                    Restart</button>
                <button onclick="endPlaytest()"
                    style="padding: 15px 40px; background: #ff3366; color: #fff; border: none; border-radius: 8px; font-family: 'Orbitron', sans-serif; font-size: 1rem; cursor: pointer;">✕
                    Back to Editor</button>
            </div>
        </div>
    </div>

    <script>
        // ===== STATE =====
        let notes = [];
        let selectedNotes = new Set(); // Changed to Set for multi-select
        let copiedNotes = []; // Clipboard
        let currentTool = 'red';
        let audio = null;
        let audioData = null; // Base64 audio data for drafts
        let isPlaying = false;
        let zoomLevel = 5;
        let pixelsPerMs = 0.1;
        let backgroundImage = null;
        let backgroundFilename = '';
        let backgroundData = null; // Base64 background data for drafts
        let isDraggingPlayhead = false;
        let isDraggingNote = false;
        let isResizingHold = false;
        let wasDragging = false;
        let draggedNoteIndex = -1;
        let resizingNoteIndex = -1; // New tracker for resizing

        let isRecording = false;
        let recordingKeys = {};

        // Playtest state
        let isPlaytesting = false;
        let playtestStartTime = 0;

        // Undo/Redo State
        const historyStack = [];
        const redoStack = [];
        const MAX_HISTORY = 50;

        // Context Menu Helper
        function hideContextMenu() {
            const menu = document.getElementById('context-menu');
            if (menu) menu.style.display = 'none';
        }

        function saveState() {
            // Deep copy notes to history
            const state = JSON.stringify(notes);
            historyStack.push(state);
            if (historyStack.length > MAX_HISTORY) historyStack.shift();
            redoStack.length = 0; // Clear redo stack on new action
            console.log('State Saved', historyStack.length);
        }

        function undo() {
            if (historyStack.length === 0) return;
            const currentState = JSON.stringify(notes);
            redoStack.push(currentState);

            const prevState = historyStack.pop();
            notes = JSON.parse(prevState);

            // Restore selection? verifying if indices match is hard if notes changed order.
            // For now clear selection to be safe.
            selectedNotes.clear();

            updateTimeline();
            drawPreview();
            console.log('Undo performed');
        }

        function redo() {
            if (redoStack.length === 0) return;
            const currentState = JSON.stringify(notes);
            historyStack.push(currentState);

            const nextState = redoStack.pop();
            notes = JSON.parse(nextState);

            selectedNotes.clear();
            updateTimeline();
            drawPreview();
            console.log('Redo performed');
        }

        async function autoMap() {
            if (!audio) {
                alert('Please load an audio file first');
                return;
            }

            const bpmInput = parseInt(prompt("Enter song BPM (Approximate is fine):", "120")) || 120;
            const difficulty = prompt("Select Difficulty (Easy, Normal, Hard, Expert):", "Normal") || "Normal";

            if (!confirm(`Generate ${difficulty} map at ${bpmInput} BPM? This will overwrite existing notes.`)) return;

            try {
                // Decode Audio
                const offlineCtx = new OfflineAudioContext(1, audio.duration * 44100, 44100);
                const source = offlineCtx.createBufferSource();
                const response = await fetch(audio.src);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await offlineCtx.decodeAudioData(arrayBuffer);

                const rawData = audioBuffer.getChannelData(0);
                const sampleRate = audioBuffer.sampleRate;

                // ===== AUTO MAP V6 (HYBRID: ONSET + SECTION) =====

                // --- Difficulty Settings ---
                const diffSettings = {
                    'Easy': { threshold: 1.6, grid: 2, minGap: 400, minHold: 400 },
                    'Normal': { threshold: 1.4, grid: 4, minGap: 250, minHold: 300 },
                    'Hard': { threshold: 1.2, grid: 4, minGap: 150, minHold: 200 },
                    'Expert': { threshold: 1.0, grid: 8, minGap: 100, minHold: 150 }
                };
                const settings = diffSettings[difficulty] || diffSettings['Normal'];

                // --- 1. Spectral Analysis (Bass/Treble Separation) ---
                const windowSize = Math.floor(sampleRate / 60); // ~16ms windows
                const bassProfile = [];
                const trebleProfile = [];

                // Simple IIR low-pass filter for bass separation
                const alpha = 0.05;
                let lastOut = 0;


                for (let i = 0; i < rawData.length; i += windowSize) {
                    let sumBass = 0;
                    let sumTreble = 0;

                    for (let j = 0; j < windowSize && (i + j) < rawData.length; j++) {
                        const sample = rawData[i + j];
                        const lp = lastOut + alpha * (sample - lastOut);
                        lastOut = lp;
                        const hp = sample - lp;

                        sumBass += lp * lp;
                        sumTreble += hp * hp;
                    }
                    bassProfile.push(Math.sqrt(sumBass / windowSize));
                    trebleProfile.push(Math.sqrt(sumTreble / windowSize));
                }

                // --- 2. Dynamic Calibration (Fix "no chorus" issue) ---
                const bassAvg = bassProfile.reduce((a, b) => a + b, 0) / bassProfile.length;
                const trebleAvg = trebleProfile.reduce((a, b) => a + b, 0) / trebleProfile.length;

                // --- 3. Section Analysis (4-bar chunks for density control) ---
                const beatMs = 60000 / bpmInput;
                const beatsPerChunk = 16;
                const chunksData = [];

                for (let beatIdx = 0; beatIdx < (audio.duration * 1000 / beatMs); beatIdx += beatsPerChunk) {
                    const startFrame = Math.floor((beatIdx * beatMs / 1000) * (sampleRate / windowSize));
                    const endFrame = Math.floor(((beatIdx + beatsPerChunk) * beatMs / 1000) * (sampleRate / windowSize));

                    let chunkEnergy = 0;
                    let count = 0;
                    for (let f = startFrame; f < endFrame && f < bassProfile.length; f++) {
                        chunkEnergy += bassProfile[f] + trebleProfile[f];
                        count++;
                    }
                    const avgEnergy = count > 0 ? chunkEnergy / count : 0;

                    // Classify section
                    let sectionType = 'verse';
                    if (avgEnergy > (bassAvg + trebleAvg) * 1.3) sectionType = 'chorus';
                    else if (avgEnergy < (bassAvg + trebleAvg) * 0.6) sectionType = 'break';

                    chunksData.push({ startBeat: beatIdx, type: sectionType, energy: avgEnergy });
                }

                // --- 4. Onset Detection (V4 Revival) ---
                const generatedNotes = [];
                let lastNoteTime = 0;
                const localWindow = 50;

                // Helper: Snap to Grid
                const snapTime = (timeMs, gridDivisor) => {
                    const snapInterval = beatMs / (gridDivisor / 4);
                    return Math.round(timeMs / snapInterval) * snapInterval;
                };

                // Helper: Find current section
                const getSectionAt = (timeMs) => {
                    const beatIdx = timeMs / beatMs;
                    for (let i = chunksData.length - 1; i >= 0; i--) {
                        if (beatIdx >= chunksData[i].startBeat) return chunksData[i];
                    }
                    return { type: 'verse', energy: 0 };
                };

                for (let i = 0; i < bassProfile.length; i++) {
                    const timeMs = (i * windowSize / sampleRate) * 1000;
                    const section = getSectionAt(timeMs);

                    // Section-based threshold adjustment
                    let thresholdMult = settings.threshold;
                    let gridDivisor = settings.grid;

                    if (section.type === 'chorus') {
                        thresholdMult *= 0.8; // More sensitive in chorus
                        gridDivisor = Math.max(gridDivisor, 4); // Finer grid
                    } else if (section.type === 'break') {
                        thresholdMult *= 1.5; // Less sensitive in breaks
                        gridDivisor = 2; // Coarser grid
                    }

                    // Local averages for adaptive thresholding
                    let localBassSum = 0;
                    let localTrebleSum = 0;
                    let count = 0;
                    for (let k = -localWindow / 2; k < localWindow / 2; k++) {
                        if (i + k >= 0 && i + k < bassProfile.length) {
                            localBassSum += bassProfile[i + k];
                            localTrebleSum += trebleProfile[i + k];
                            count++;
                        }
                    }
                    const localBassAvg = localBassSum / count;
                    const localTrebleAvg = localTrebleSum / count;

                    const bassVal = bassProfile[i];
                    const trebleVal = trebleProfile[i];

                    // Peak Detection
                    let isBassPeak = true;
                    let isTreblePeak = true;
                    for (let k = -3; k <= 3; k++) {
                        if (i + k >= 0 && i + k < bassProfile.length) {
                            if (bassProfile[i + k] > bassVal) isBassPeak = false;
                            if (trebleProfile[i + k] > trebleVal) isTreblePeak = false;
                        }
                    }

                    // Note candidates
                    const isBassNote = isBassPeak && bassVal > localBassAvg * thresholdMult && bassVal > bassAvg * 0.5;
                    const isTrebleNote = isTreblePeak && trebleVal > localTrebleAvg * thresholdMult && trebleVal > trebleAvg * 0.5;

                    if ((isBassNote || isTrebleNote) && (timeMs - lastNoteTime > settings.minGap)) {
                        const snap = snapTime(timeMs, gridDivisor);

                        // Type: Bass = Red (Kick), Treble = Blue (Snare/Vocal)
                        let type = isBassNote ? 'red' : 'blue';

                        // --- Hold / Spam Detection ---
                        let sustainLength = 0;
                        if (isBassNote) {
                            for (let k = 1; k < 100; k++) {
                                if (i + k < bassProfile.length && bassProfile[i + k] > localBassAvg * 1.1) {
                                    sustainLength++;
                                } else break;
                            }
                        }

                        const rawDuration = (sustainLength * windowSize / sampleRate) * 1000;

                        // Spam (Drumroll) - Only in Hard/Expert
                        if (difficulty === 'Hard' || difficulty === 'Expert') {
                            if (sustainLength > 30 && bassVal > bassAvg * 2.0 && section.type === 'chorus') {
                                generatedNotes.push({
                                    time: snap,
                                    type: 'spam',
                                    endTime: snap + Math.max(rawDuration, 500),
                                    spamRequired: Math.floor(rawDuration / 80)
                                });
                                lastNoteTime = snap + rawDuration;
                                i += sustainLength;
                                continue;
                            }
                        }

                        // Hold (Sustained tones)
                        if (rawDuration > settings.minHold) {
                            generatedNotes.push({
                                time: snap,
                                type: 'hold',
                                endTime: snap + rawDuration
                            });
                            lastNoteTime = snap + rawDuration * 0.5;
                        } else {
                            // Normal Tap
                            generatedNotes.push({ time: snap, type: type });
                            lastNoteTime = snap;
                        }
                    }
                }

                // Final Cleanup
                generatedNotes.sort((a, b) => a.time - b.time);
                const uniqueNotes = [];
                if (generatedNotes.length > 0) uniqueNotes.push(generatedNotes[0]);

                for (let i = 1; i < generatedNotes.length; i++) {
                    const prev = uniqueNotes[uniqueNotes.length - 1];
                    const curr = generatedNotes[i];
                    if (curr.time - prev.time > 20) uniqueNotes.push(curr);
                }

                if (uniqueNotes.length === 0) {
                    alert("No significant peaks found. Try adjusting BPM or difficulty.");
                    return;
                }

                if (typeof saveState === 'function') saveState();
                notes = uniqueNotes;

                // Metadata
                document.getElementById('song-bpm').value = bpmInput;
                document.getElementById('song-difficulty').value = difficulty;
                document.getElementById('difficulty-level').value = difficulty === 'Expert' ? 9 : (difficulty === 'Hard' ? 7 : (difficulty === 'Normal' ? 4 : 2));

                updateTimeline();
                drawPreview();
                alert(`Generated ${notes.length} notes (V6 Hybrid)! Detected ${chunksData.filter(c => c.type === 'chorus').length} chorus sections.`);


            } catch (e) {
                console.error("Auto Map Failed", e);
                alert("Failed to auto-generate map. Check console for details.");
            }
        }
        const previewCanvas = document.getElementById('preview-canvas');
        const previewCtx = previewCanvas.getContext('2d');

        // ===== INITIALIZATION =====
        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            updateTimeline();
            drawPreview();

            // Hide context menu on click elsewhere
            document.addEventListener('click', () => {
                hideContextMenu();
            });

            // Fix sticking drag by ensuring mouseup on window clears everything
            window.addEventListener('mouseup', handleGlobalMouseUp);
        });

        function setupEventListeners() {
            // Audio file input
            document.getElementById('audio-input').addEventListener('change', handleAudioLoad);
            document.getElementById('map-input').addEventListener('change', handleMapImport);
            document.getElementById('bg-input').addEventListener('change', handleBackgroundLoad);

            // Zoom slider
            document.getElementById('zoom-slider').addEventListener('input', (e) => {
                zoomLevel = parseInt(e.target.value);
                pixelsPerMs = 0.05 * zoomLevel;
                updateTimeline();
                updatePlayheadPosition();
            });

            // Snap select change - update grid
            document.getElementById('snap-select').addEventListener('change', () => {
                updateTimeline();
            });

            // BPM change - update grid
            document.getElementById('song-bpm').addEventListener('change', () => {
                updateTimeline();
            });

            // Timeline click to add notes
            document.getElementById('timeline').addEventListener('click', handleTimelineClick);

            // Ruler click to seek
            document.getElementById('timeline-ruler').addEventListener('click', (e) => {
                if (!audio) return;
                e.stopPropagation(); // Prevent adding notes

                const timeline = document.getElementById('timeline');
                const scroll = document.getElementById('timeline-scroll');
                const rect = timeline.getBoundingClientRect();
                const x = e.clientX - rect.left + scroll.scrollLeft;
                const time = Math.max(0, x / pixelsPerMs);

                // Clamp to audio duration
                const clampedTime = Math.min(time, audio.duration * 1000);
                audio.currentTime = clampedTime / 1000;

                // Update playhead
                const playhead = document.getElementById('playhead');
                playhead.style.left = `${clampedTime * pixelsPerMs}px`;

                // Update time display
                const mins = Math.floor(audio.currentTime / 60);
                const secs = Math.floor(audio.currentTime % 60);
                const ms = Math.floor((audio.currentTime % 1) * 1000);
                document.getElementById('time-display').textContent =
                    `${mins}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;

                drawPreview(clampedTime);
            });

            // Timeline Right-Click (Context Menu)
            document.getElementById('timeline').addEventListener('contextmenu', (e) => {
                e.preventDefault();
                const menu = document.getElementById('context-menu');
                menu.style.display = 'block';
                menu.style.left = `${e.pageX}px`;
                menu.style.top = `${e.pageY}px`;
            });

            // Scroll Wheel & Zoom
            document.getElementById('timeline-scroll').addEventListener('wheel', (e) => {
                e.preventDefault();
                if (e.ctrlKey) {
                    // Zoom
                    const zoomChange = e.deltaY > 0 ? -1 : 1;
                    let newZoom = zoomLevel + zoomChange;
                    newZoom = Math.max(1, Math.min(20, newZoom)); // Clamp 1-20
                    if (newZoom !== zoomLevel) {
                        zoomLevel = newZoom;
                        pixelsPerMs = 0.05 * zoomLevel;
                        document.getElementById('zoom-slider').value = zoomLevel;
                        updateTimeline();
                        updatePlayheadPosition();
                    }
                } else {
                    // Scroll
                    const scroll = document.getElementById('timeline-scroll');
                    scroll.scrollLeft += e.deltaY;
                }
            }, { passive: false });

            // Keyboard shortcuts
            document.addEventListener('keydown', handleKeyboard);

            // Playhead dragging
            const playhead = document.getElementById('playhead');
            playhead.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                isDraggingPlayhead = true;
                document.body.style.cursor = 'ew-resize';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDraggingPlayhead && !isDraggingNote && !isResizingHold) return;

                const timelineScroll = document.getElementById('timeline-scroll');
                const timeline = document.getElementById('timeline');
                const rect = timeline.getBoundingClientRect();

                // Calculate x position relative to timeline, accounting for scroll
                const x = e.clientX - rect.left + timelineScroll.scrollLeft;

                // Only handle playhead dragging here
                if (isDraggingPlayhead) {
                    // Clamp x to valid range
                    const maxX = audio ? audio.duration * 1000 * pixelsPerMs : timeline.offsetWidth;
                    const clampedX = Math.max(0, Math.min(x, maxX));
                    const newTime = clampedX / pixelsPerMs;

                    if (audio && audio.duration) {
                        const clampedTime = Math.min(newTime, audio.duration * 1000);
                        audio.currentTime = clampedTime / 1000;
                    }

                    // Update playhead position
                    playhead.style.left = `${clampedX}px`;

                    // Update time display
                    const displayTime = newTime / 1000;
                    const mins = Math.floor(displayTime / 60);
                    const secs = Math.floor(displayTime % 60);
                    const ms = Math.floor((displayTime % 1) * 1000);
                    document.getElementById('time-display').textContent =
                        `${mins}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;

                    drawPreview(newTime);
                }
            });

            // Replaced by global handler
            // document.addEventListener('mouseup', () => { ... });
        } // End setupEventListeners()

        function handleGlobalMouseUp(e) {
            if (e.button === 2) return; // Ignore right click

            // Save state if we finished a drag operation that changed things
            if ((isDraggingNote && draggedNoteIndex !== -1) || (isResizingHold && resizingNoteIndex !== -1)) {
                // State already saved on mousedown
            }

            if (isDraggingPlayhead || isDraggingNote || isResizingHold) {
                wasDragging = true;
                setTimeout(() => wasDragging = false, 50);
            }

            if (isDraggingPlayhead) {
                isDraggingPlayhead = false;
                document.body.style.cursor = '';
            }
            if (isDraggingNote) {
                isDraggingNote = false;
                draggedNoteIndex = -1;
                document.body.style.cursor = '';
                notes.sort((a, b) => a.time - b.time);
                updateTimeline();
            }
            if (isResizingHold) {
                isResizingHold = false;
                resizingNoteIndex = -1;
                document.body.style.cursor = '';
                updateTimeline();
            }
        }

        document.addEventListener('mousemove', (e) => {
            // Note Dragging Logic
            if (isDraggingNote && draggedNoteIndex !== -1) {
                const timeline = document.getElementById('timeline');
                const scroll = document.getElementById('timeline-scroll');
                const rect = timeline.getBoundingClientRect();
                const x = e.clientX - rect.left + scroll.scrollLeft;
                let time = Math.max(0, x / pixelsPerMs);

                // Snap Logic
                const snapDivisor = parseInt(document.getElementById('snap-select').value);
                if (snapDivisor > 0) {
                    const bpm = parseInt(document.getElementById('song-bpm').value) || 120;
                    const msPerBeat = 60000 / bpm;
                    const msPerSnap = msPerBeat / (snapDivisor / 1);
                    time = Math.round(time / msPerSnap) * msPerSnap;
                } else {
                    time = Math.round(time);
                }

                // Calculate delta for multi-select
                const originalTime = notes[draggedNoteIndex].time;
                const delta = time - originalTime;

                // Update Data
                notes[draggedNoteIndex].time = time;
                if (notes[draggedNoteIndex].endTime) {
                    const duration = notes[draggedNoteIndex].endTime - originalTime;
                    notes[draggedNoteIndex].endTime = time + duration;
                }

                // Update DOM directly (Performant & fixes sticking)
                const marker = document.querySelector(`.note-marker[data-index="${draggedNoteIndex}"]`);
                if (marker) {
                    marker.style.left = `${time * pixelsPerMs}px`;

                    // Update hold trail if exists
                    if (notes[draggedNoteIndex].type === 'hold') {
                        // Find the trail in the same track container? 
                        // It's safer to find by structure if we don't have IDs.
                        // Holding track is index 2.
                        // Actually, let's just use updateTimeline ONLY if we really have to, 
                        // OR (better) just rely on the note marker moving for now, 
                        // and update trail on mouseup. 
                        // But user wants to see it move.
                        // Let's try to update trail too.
                        // The hold-trail is a sibling or near the marker? 
                        // In renderNotes: track.appendChild(marker); track.appendChild(trail);
                        // They are not parent/child.
                        // This makes easy toggle hard.
                        // FALLBACK: If it's a hold note, we might NEED to re-render OR do expensive DOM search.
                        // For now, let's just move the marker. The trail update on mouseup is acceptable 
                        // vs the "glued" bug.
                        // OR we can find sibling hold-trail with matching left/width? Hard/Fragile.
                    }
                }

                // Multi-select move
                if (selectedNotes.has(draggedNoteIndex) && selectedNotes.size > 1) {
                    selectedNotes.forEach(idx => {
                        if (idx !== draggedNoteIndex) {
                            notes[idx].time += delta;
                            if (notes[idx].endTime) notes[idx].endTime += delta;

                            const m = document.querySelector(`.note-marker[data-index="${idx}"]`);
                            if (m) m.style.left = `${notes[idx].time * pixelsPerMs}px`;
                        }
                    });
                }

                // drawPreview(time); // Optional: might be heavy?
            }

            // Hold Resizing Logic
            if (isResizingHold && resizingNoteIndex !== -1) {
                const timeline = document.getElementById('timeline');
                const scroll = document.getElementById('timeline-scroll');
                const rect = timeline.getBoundingClientRect();
                const x = e.clientX - rect.left + scroll.scrollLeft;
                let time = Math.max(0, x / pixelsPerMs);

                // Snap Logic 
                const snapDivisor = parseInt(document.getElementById('snap-select').value);
                if (snapDivisor > 0) {
                    const bpm = parseInt(document.getElementById('song-bpm').value) || 120;
                    const msPerBeat = 60000 / bpm;
                    const msPerSnap = msPerBeat / (snapDivisor / 1);
                    time = Math.round(time / msPerSnap) * msPerSnap;
                }

                // Enforce start time < end time
                const startTime = notes[resizingNoteIndex].time;
                if (time > startTime) {
                    notes[resizingNoteIndex].endTime = time;
                    updateTimeline(); // We use updateTimeline for resize as it simplifies UI update (handle pos etc)
                    drawPreview(startTime);
                }
            }
        });


        // Playback update using requestAnimationFrame for better performance
        function playbackLoop() {
            updatePlayback();
            requestAnimationFrame(playbackLoop);
        }
        requestAnimationFrame(playbackLoop);

        // ===== TOOL SELECTION =====
        function selectTool(type) {
            currentTool = type;
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.type === type);
            });

            // Show/hide relevant options
            document.getElementById('hold-duration-group').style.display = type === 'hold' ? 'block' : 'none';
            document.getElementById('spam-count-group').style.display = type === 'spam' ? 'block' : 'none';
        }

        // ===== AUDIO =====
        function loadAudio() {
            document.getElementById('audio-input').click();
        }

        function handleAudioLoad(e) {
            const file = e.target.files[0];
            if (!file) return;

            // Warn about large audio files (> 5MB) as they may not save properly in drafts
            const MAX_AUDIO_SIZE = 5 * 1024 * 1024; // 5MB
            if (file.size > MAX_AUDIO_SIZE) {
                const sizeMB = (file.size / (1024 * 1024)).toFixed(1);
                console.log(`Audio file is ${sizeMB}MB - may be too large for draft storage`);
            }

            const url = URL.createObjectURL(file);
            audio = new Audio(url);
            audio.addEventListener('loadedmetadata', () => {
                updateTimeline();
            });
            audio.addEventListener('ended', () => {
                isPlaying = false;
                document.getElementById('play-btn').textContent = '▶';

                // If in playtest mode, return to editor when song ends
                if (isPlaytesting) {
                    endPlaytest();
                }
            });

            // Store audio as base64 for draft saving
            const reader = new FileReader();
            reader.onload = (event) => {
                audioData = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function togglePlay() {
            if (!audio) {
                alert('Please load an audio file first');
                return;
            }

            if (isPlaying) {
                audio.pause();
                isPlaying = false;
                document.getElementById('play-btn').textContent = '▶';
            } else {
                audio.play();
                isPlaying = true;
                document.getElementById('play-btn').textContent = '⏸';
            }
        }

        function stopAndReset() {
            if (!audio) return;

            // Stop playback and go to beginning
            audio.pause();
            audio.currentTime = 0;
            isPlaying = false;
            document.getElementById('play-btn').textContent = '▶';

            // Update playhead position
            const playhead = document.getElementById('playhead');
            playhead.style.left = '0px';

            // Update time display
            document.getElementById('time-display').textContent = '0:00.000';

            // Scroll timeline to beginning
            document.getElementById('timeline-scroll').scrollLeft = 0;

            // Update preview
            drawPreview(0);
        }

        // ===== PLAYTEST MODE =====
        function startPlaytest() {
            if (!audio) {
                alert('Please load an audio file first');
                return;
            }
            if (notes.length === 0) {
                alert('No notes to playtest. Add some notes first!');
                return;
            }

            // Save current state as playtest data
            const playtestData = {
                title: document.getElementById('song-title').value,
                artist: document.getElementById('song-artist').value,
                difficulty: document.getElementById('song-difficulty').value,
                difficultyLevel: document.getElementById('difficulty-level').value,
                bpm: document.getElementById('song-bpm').value,
                notes: notes,
                backgroundFilename: backgroundFilename,
                backgroundData: backgroundData, // Save background image data
                audioData: audioData // Save audio data
            };

            // Use IndexedDB for storage (Bypasses localStorage 5MB limit)
            const request = indexedDB.open('RhythmCircleDB', 2); // Use v2 to match saveDraft

            request.onupgradeneeded = function (event) {
                const db = event.target.result;
                if (!db.objectStoreNames.contains('playtest')) {
                    db.createObjectStore('playtest', { keyPath: 'id' });
                }
                if (!db.objectStoreNames.contains('drafts')) {
                    db.createObjectStore('drafts', { keyPath: 'id' });
                }
            };

            request.onsuccess = function (event) {
                const db = event.target.result;
                const transaction = db.transaction(['playtest'], 'readwrite');
                const store = transaction.objectStore('playtest');

                // Use a fixed ID 'current' for the playtest data
                const putRequest = store.put({ id: 'current', data: playtestData });

                putRequest.onsuccess = function () {
                    console.log("Playtest data saved to IndexedDB");
                    // Redirect to main game with playtest flag
                    window.location.href = '../index.html?playtest=true';
                };

                putRequest.onerror = function (e) {
                    console.error("IndexedDB Error", e);
                    alert("Failed to save playtest data to IndexedDB: " + e.target.error);
                };

                transaction.oncomplete = function () {
                    console.log("Transaction completed");
                };

                transaction.onerror = function (e) {
                    console.error("Transaction error", e);
                    alert("Transaction failed: " + e.target.error);
                };
            };

            request.onerror = function (event) {
                console.error("IndexedDB Open Error", event);
                alert("Failed to open database for playtest");
            };
        }

        // Keyboard handler for playtest
        document.addEventListener('keydown', (e) => {
            if (!isPlaytesting) return;

            if (e.code === 'Escape') {
                if (playtestPaused) {
                    resumePlaytest();
                } else {
                    pausePlaytest();
                }
                e.preventDefault();
            }
        });

        // ===== BACKGROUND =====
        function loadBackground() {
            document.getElementById('bg-input').click();
        }

        function handleBackgroundLoad(e) {
            const file = e.target.files[0];
            if (!file) return;

            // Warn about large files (> 2MB) as they may not save properly
            const MAX_BG_SIZE = 2 * 1024 * 1024; // 2MB
            if (file.size > MAX_BG_SIZE) {
                const sizeMB = (file.size / (1024 * 1024)).toFixed(1);
                if (!confirm(`The background image is ${sizeMB}MB which may be too large to save in drafts. Continue anyway?`)) {
                    return;
                }
            }

            backgroundFilename = file.name;
            document.getElementById('bg-filename').textContent = backgroundFilename;

            const reader = new FileReader();
            reader.onload = (event) => {
                backgroundData = event.target.result; // Store base64 data for drafts
                const img = new Image();
                img.onload = () => {
                    backgroundImage = img;
                    drawPreview();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function updatePlayback() {
            if (!audio) return;
            if (isDraggingPlayhead) return; // Don't update while dragging

            const currentTime = audio.currentTime * 1000;
            const playhead = document.getElementById('playhead');
            playhead.style.left = `${currentTime * pixelsPerMs}px`;

            // Update time display
            const mins = Math.floor(audio.currentTime / 60);
            const secs = Math.floor(audio.currentTime % 60);
            const ms = Math.floor((audio.currentTime % 1) * 1000);
            document.getElementById('time-display').textContent =
                `${mins}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;

            // Auto-scroll timeline
            if (isPlaying) {
                const scroll = document.getElementById('timeline-scroll');
                const playheadX = currentTime * pixelsPerMs;
                const viewportWidth = scroll.clientWidth;
                if (playheadX > scroll.scrollLeft + viewportWidth - 100) {
                    scroll.scrollLeft = playheadX - 100;
                }
            }

            drawPreview(currentTime);
        }

        // Update playhead position based on current audio time (used when zooming)
        function updatePlayheadPosition() {
            if (!audio) return;
            const currentTime = audio.currentTime * 1000;
            const playhead = document.getElementById('playhead');
            playhead.style.left = `${currentTime * pixelsPerMs}px`;
        }

        // ===== TIMELINE =====
        function updateTimeline() {
            const timeline = document.getElementById('timeline');
            const ruler = document.getElementById('timeline-ruler');
            const tracks = document.querySelector('.timeline-tracks');

            // Calculate timeline width
            const duration = audio ? audio.duration * 1000 : 60000;
            const width = duration * pixelsPerMs;
            timeline.style.width = `${Math.max(width, window.innerWidth)}px`;

            // Get snap settings
            const snapDivisor = parseInt(document.getElementById('snap-select').value) || 0;
            const bpm = parseInt(document.getElementById('song-bpm').value) || 120;
            const beatInterval = 60000 / bpm;

            // Draw ruler with beat markers
            ruler.innerHTML = '';

            for (let t = 0; t < duration; t += beatInterval) {
                const isMeasureStart = t % (beatInterval * 4) === 0;
                const marker = document.createElement('div');
                marker.style.cssText = `
                    position: absolute;
                    left: ${t * pixelsPerMs}px;
                    top: 0;
                    height: 100%;
                    width: ${isMeasureStart ? '2px' : '1px'};
                    background: ${isMeasureStart ? '#666' : '#444'};
                    pointer-events: none;
                `;
                ruler.appendChild(marker);

                // Time labels every 4 beats
                if (isMeasureStart) {
                    const label = document.createElement('span');
                    label.style.cssText = `
                        position: absolute;
                        left: ${t * pixelsPerMs + 5}px;
                        top: 5px;
                        font-size: 10px;
                        color: #888;
                        pointer-events: none;
                    `;
                    label.textContent = `${Math.floor(t / 1000)}s`;
                    ruler.appendChild(label);
                }
            }

            // Draw grid lines in tracks based on snap setting
            // Remove old grid lines
            document.querySelectorAll('.track-grid-line').forEach(el => el.remove());

            if (snapDivisor > 0) {
                const msPerSnap = beatInterval / snapDivisor;
                const trackElements = tracks.querySelectorAll('.track');

                // Optimize: Only draw grid lines up to a reasonable limit
                const maxGridLines = 1000;
                const gridLineInterval = Math.max(msPerSnap, duration / maxGridLines);

                // Use document fragment for better performance
                const fragment = document.createDocumentFragment();

                for (let t = 0; t < duration; t += gridLineInterval) {
                    const isBeat = Math.abs(t % beatInterval) < 1;
                    const isMeasureStart = Math.abs(t % (beatInterval * 4)) < 1;

                    trackElements.forEach(track => {
                        const gridLine = document.createElement('div');
                        gridLine.className = 'track-grid-line';
                        let lineColor, lineWidth;

                        if (isMeasureStart) {
                            lineColor = 'rgba(255, 255, 255, 0.3)';
                            lineWidth = '2px';
                        } else if (isBeat) {
                            lineColor = 'rgba(255, 255, 255, 0.15)';
                            lineWidth = '1px';
                        } else {
                            lineColor = 'rgba(255, 255, 255, 0.05)';
                            lineWidth = '1px';
                        }

                        gridLine.style.cssText = `
                            position: absolute;
                            left: ${t * pixelsPerMs}px;
                            top: 0;
                            height: 100%;
                            width: ${lineWidth};
                            background: ${lineColor};
                            pointer-events: none;
                            z-index: 0;
                        `;
                        track.appendChild(gridLine);
                    });
                }
            }

            // Render notes
            renderNotes();
        }

        function renderNotes() {
            // Clear existing note markers
            document.querySelectorAll('.note-marker, .hold-trail').forEach(el => el.remove());

            const tracks = document.querySelector('.timeline-tracks');

            notes.forEach((note, index) => {
                const marker = document.createElement('div');
                marker.className = `note-marker ${note.type}`;
                marker.style.left = `${note.time * pixelsPerMs}px`;
                marker.dataset.index = index;
                if (selectedNotes.has(index)) marker.classList.add('selected');

                marker.onmousedown = (e) => {
                    e.stopPropagation();

                    // Multi-select Logic
                    if (e.shiftKey) {
                        if (selectedNotes.has(index)) {
                            selectedNotes.delete(index);
                        } else {
                            selectedNotes.add(index);
                        }
                    } else if (!selectedNotes.has(index)) {
                        selectedNotes.clear();
                        selectedNotes.add(index);
                    }

                    saveState(); // Save before drag starts
                    startDragNote(index, e);
                    updateTimeline(); // Refresh selection visuals
                };

                // Determine track
                let trackIndex = 0;
                if (note.type === 'blue') trackIndex = 1;
                if (note.type === 'hold' || note.type === 'spam') trackIndex = 2;

                const track = tracks.children[trackIndex];
                track.appendChild(marker);

                // Hold trail
                if (note.type === 'hold' && note.endTime) {
                    const trail = document.createElement('div');
                    trail.className = 'hold-trail';
                    trail.style.left = `${note.time * pixelsPerMs}px`;
                    trail.style.width = `${(note.endTime - note.time) * pixelsPerMs}px`;

                    // Resize Handle
                    const handle = document.createElement('div');
                    handle.className = 'hold-resize-handle';
                    handle.onmousedown = (e) => {
                        e.stopPropagation();
                        saveState(); // Save before resize
                        isResizingHold = true;
                        resizingNoteIndex = index;
                        document.body.style.cursor = 'e-resize';
                    };
                    trail.appendChild(handle);

                    track.appendChild(trail);
                }
            }); // This closes the forEach loop

            // Update note list
            updateNoteList();
        }

        function handleTimelineClick(e) {
            // Prevent placing note if dragging something or just finished dragging
            if (isDraggingPlayhead || isDraggingNote || wasDragging) return;
            // Also prevent if clicking a note marker (handled by note click/drag)
            if (e.target.classList.contains('note-marker')) return;
            // Prevent if clicking on hold trail or resize handle
            if (e.target.classList.contains('hold-trail') || e.target.classList.contains('hold-resize-handle')) return;

            // Clear selection when clicking on empty timeline space
            selectedNotes.clear();

            const timeline = document.getElementById('timeline');
            const rect = timeline.getBoundingClientRect();
            const x = e.clientX - rect.left + document.getElementById('timeline-scroll').scrollLeft;
            let time = x / pixelsPerMs;

            // SNAP LOGIC
            const snapDivisor = parseInt(document.getElementById('snap-select').value);
            if (snapDivisor > 0) {
                const bpm = parseInt(document.getElementById('song-bpm').value) || 120;
                const msPerBeat = 60000 / bpm;
                const msPerSnap = msPerBeat / (snapDivisor / 1); // e.g. 1/4 beat

                time = Math.round(time / msPerSnap) * msPerSnap;
            } else {
                time = Math.round(time);
            }

            addNote(time);
        }

        // ===== NOTE MANAGEMENT =====
        function addNoteAtCurrentTime(type) {
            if (!audio) return;
            // Use current tool settings but override type
            const savedTool = currentTool;
            currentTool = type;

            // Calculate time
            let time = audio.currentTime * 1000;

            // Optional: Quantize if snap is on
            const snapDivisor = parseInt(document.getElementById('snap-select').value);
            if (snapDivisor > 0) {
                const bpm = parseInt(document.getElementById('song-bpm').value) || 120;
                const msPerBeat = 60000 / bpm;
                const msPerSnap = msPerBeat / (snapDivisor / 1);
                time = Math.round(time / msPerSnap) * msPerSnap;
            }

            addNote(time);

            currentTool = savedTool; // Restore tool
        }

        function addNote(time) {
            saveState(); // Save before adding

            const note = {
                time: time,
                type: currentTool
            };

            if (currentTool === 'hold') {
                const duration = parseInt(document.getElementById('hold-duration').value) || 1000;
                // Snap duration too if snapping is enabled? Maybe just start time for now.
                note.endTime = time + duration;
            }

            if (currentTool === 'spam') {
                note.spamRequired = parseInt(document.getElementById('spam-count').value) || 5;
            }

            notes.push(note);
            notes.sort((a, b) => a.time - b.time);

            updateTimeline();
            drawPreview(time); // Show preview at note time
        }

        function selectNote(index) {
            selectedNote = null; // Clear single selection
            selectedNotes.clear(); // Clear multi-selection
            selectedNotes.add(index); // Add this one
            document.querySelectorAll('.note-marker').forEach(m => m.classList.remove('selected'));
            document.querySelector(`.note-marker[data-index="${index}"]`)?.classList.add('selected');
        }

        function startDragNote(index, e) {
            isDraggingNote = true;
            draggedNoteIndex = index;
            document.body.style.cursor = 'grabbing';
        }

        function deleteNote(index) {
            saveState(); // Save before deleting
            notes.splice(index, 1);
            selectedNotes.clear(); // Clear selection after delete
            updateTimeline();
            drawPreview();
        }

        function updateNoteList() {
            const list = document.getElementById('note-list');
            document.getElementById('note-count').textContent = notes.length;

            list.innerHTML = notes.map((note, i) => `
                <div class="note-item" onclick="selectNote(${i})">
                    <span class="type ${note.type}">${note.type}</span>
                    <span>${(note.time / 1000).toFixed(2)}s${note.endTime ? ' (' + ((note.endTime - note.time) / 1000).toFixed(2) + 's)' : ''}</span>
                    <button class="delete-btn" onclick="event.stopPropagation(); deleteNote(${i})">×</button>
                </div>
            `).join('');
        }

        // ===== PREVIEW =====
        function drawPreview(currentTime = 0) {
            const ctx = previewCtx;
            const w = previewCanvas.width;
            const h = previewCanvas.height;
            const cx = w / 2;
            const cy = h / 2;

            // Clear / Draw background
            if (backgroundImage) {
                // Draw background image (cover style)
                const imgRatio = backgroundImage.width / backgroundImage.height;
                const canvasRatio = w / h;
                let drawW, drawH, drawX, drawY;

                if (imgRatio > canvasRatio) {
                    drawH = h;
                    drawW = h * imgRatio;
                    drawX = (w - drawW) / 2;
                    drawY = 0;
                } else {
                    drawW = w;
                    drawH = w / imgRatio;
                    drawX = 0;
                    drawY = (h - drawH) / 2;
                }

                ctx.drawImage(backgroundImage, drawX, drawY, drawW, drawH);
                // Add dark overlay for visibility
                ctx.fillStyle = 'rgba(10, 10, 26, 0.7)';
                ctx.fillRect(0, 0, w, h);
            } else {
                ctx.fillStyle = '#0a0a1a';
                ctx.fillRect(0, 0, w, h);
            }

            // Draw center ring (Hit Area)
            const DISPLAY_RADIUS = 100; // Matched to Game's 100
            const SPAWN_RADIUS = 400; // Matched to Game

            // Hit Area (Black Circle)
            ctx.beginPath();
            ctx.arc(cx, cy, DISPLAY_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = '#000000';
            ctx.fill();

            // Ring border
            ctx.beginPath();
            ctx.arc(cx, cy, DISPLAY_RADIUS, 0, Math.PI * 2);
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw notes
            const approachTime = 1500;

            notes.forEach(note => {
                const timeUntil = note.time - currentTime;
                const isHoldActive = (note.type === 'hold' || note.type === 'spam') && note.endTime && currentTime >= note.time && currentTime <= note.endTime;

                if (timeUntil > approachTime || (timeUntil < -200 && !isHoldActive)) return;

                // Color Selection
                let color = '#33ccff'; // Blue default
                if (note.type === 'red') color = '#ff3366';
                if (note.type === 'hold') color = '#ffcc00'; // Yellow
                if (note.type === 'spam') color = '#33ff66'; // Green

                // Radius logic matching Game.js
                const progressStart = 1 - (timeUntil / approachTime);
                let startRadius;

                if (progressStart <= 1) {
                    startRadius = SPAWN_RADIUS - (SPAWN_RADIUS - DISPLAY_RADIUS) * progressStart;
                } else {
                    const overProgress = progressStart - 1;
                    startRadius = DISPLAY_RADIUS * (1 - overProgress);
                }

                if ((note.type === 'hold' || note.type === 'spam') && note.endTime) {
                    const timeUntilEnd = note.endTime - currentTime;
                    const progressEnd = 1 - (timeUntilEnd / approachTime);
                    let endRadius;

                    if (progressEnd <= 1) {
                        endRadius = SPAWN_RADIUS - (SPAWN_RADIUS - DISPLAY_RADIUS) * progressEnd;
                    } else {
                        const overProgress = progressEnd - 1;
                        endRadius = DISPLAY_RADIUS * (1 - overProgress);
                    }

                    // Clamping for draw
                    let drawStart = Math.max(0, startRadius);
                    let drawEnd = Math.min(SPAWN_RADIUS, endRadius);

                    if (drawStart > drawEnd) [drawStart, drawEnd] = [drawEnd, drawStart];

                    if (drawEnd > 0 && drawEnd > drawStart) {
                        // Draw Hold Duration as a thick band
                        ctx.beginPath();
                        ctx.arc(cx, cy, (drawStart + drawEnd) / 2, 0, Math.PI * 2);
                        ctx.strokeStyle = color;
                        ctx.lineWidth = Math.abs(drawEnd - drawStart);
                        ctx.globalAlpha = 0.4;
                        ctx.stroke();
                        ctx.globalAlpha = 1.0;

                        // Draw edges - Head
                        if (drawStart > 10) {
                            ctx.beginPath();
                            ctx.arc(cx, cy, drawStart, 0, Math.PI * 2);
                            ctx.strokeStyle = color;
                            ctx.lineWidth = 4;
                            ctx.stroke();
                        }

                        // Tail
                        ctx.beginPath();
                        ctx.arc(cx, cy, drawEnd, 0, Math.PI * 2);
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 4;
                        ctx.stroke();

                        // Extra visual for Spam notes: Dashed inner ring
                        if (note.type === 'spam') {
                            ctx.beginPath();
                            ctx.arc(cx, cy, (drawStart + drawEnd) / 2, 0, Math.PI * 2);
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 2;
                            ctx.setLineDash([5, 15]);
                            ctx.stroke();
                            ctx.setLineDash([]);
                        }
                    }
                } else {
                    // Regular Note
                    if (startRadius <= 0) return;
                    ctx.beginPath();
                    ctx.arc(cx, cy, startRadius, 0, Math.PI * 2);

                    ctx.strokeStyle = color;
                    ctx.lineWidth = 8;

                    if (note.type === 'spam') { // Instant spam note (shouldn't happen often if auto-map makes them long)
                        ctx.setLineDash([10, 5]);
                        ctx.stroke();

                        // Inner ring
                        ctx.beginPath();
                        ctx.arc(cx, cy, Math.max(0, startRadius - 12), 0, Math.PI * 2);
                        ctx.lineWidth = 3;
                        ctx.stroke();
                        ctx.setLineDash([]);
                    } else {
                        ctx.stroke();
                    }

                    // Hit zone visual guide (Flash)
                    if (startRadius <= 100 + 20 && startRadius >= 100 - 20) {
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 4;
                        ctx.stroke();
                    }
                }
            });
        }


        // ===== KEYBOARD =====
        function handleKeyboard(e) {
            if (e.target.tagName === 'INPUT') return;

            switch (e.code) {
                case 'Space':
                    e.preventDefault();
                    togglePlay();
                    break;
                case 'KeyR':
                    e.preventDefault();
                    toggleRecordMode();
                    break;
                case 'Digit1':
                    if (isRecording && isPlaying) { addNoteAtCurrentTime('red'); }
                    else { selectTool('red'); }
                    break;
                case 'Digit2':
                    if (isRecording && isPlaying) { addNoteAtCurrentTime('blue'); }
                    else { selectTool('blue'); }
                    break;
                case 'Digit3':
                    if (isRecording && isPlaying) { addNoteAtCurrentTime('hold'); }
                    else { selectTool('hold'); }
                    break;
                case 'Digit4':
                    if (isRecording && isPlaying) { addNoteAtCurrentTime('spam'); }
                    else { selectTool('spam'); }
                    break;
                case 'Delete':
                case 'Backspace':
                    if (selectedNotes.size > 0) {
                        deleteSelectedNotes();
                    }
                    break;
            }
        }

        // ===== IMPORT/EXPORT =====
        function importMap() {
            document.getElementById('map-input').click();
        }

        function handleMapImport(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);

                    document.getElementById('song-title').value = data.title || '';
                    document.getElementById('song-artist').value = data.artist || '';
                    document.getElementById('song-difficulty').value = data.difficulty || 'Normal';
                    document.getElementById('difficulty-level').value = data.difficultyLevel || 3;
                    document.getElementById('song-bpm').value = data.bpm || 120;

                    notes = data.notes || [];
                    updateTimeline();
                    drawPreview();

                    alert('Map imported successfully!');
                } catch (err) {
                    alert('Failed to parse map file');
                }
            };
            reader.readAsText(file);
        }

        function exportMap() {
            const mapData = {
                title: document.getElementById('song-title').value || 'Untitled',
                artist: document.getElementById('song-artist').value || 'Unknown',
                difficulty: document.getElementById('song-difficulty').value,
                difficultyLevel: parseInt(document.getElementById('difficulty-level').value) || 3,
                bpm: parseInt(document.getElementById('song-bpm').value) || 120,
                audioFile: 'song.mp3',
                backgroundFile: backgroundFilename || null,
                previewTime: 0,
                notes: notes
            };

            const json = JSON.stringify(mapData, null, 4);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'map.json';
            a.click();

            URL.revokeObjectURL(url);
        }

        async function uploadMap() {
            const title = document.getElementById('song-title').value;
            if (!title) {
                alert("Please enter a Song Title before uploading.");
                return;
            }

            if (!confirm(`Upload "${title}" to the global map list?`)) return;

            const mapData = {
                title: title,
                artist: document.getElementById('song-artist').value || 'Unknown',
                difficulty: document.getElementById('song-difficulty').value,
                difficultyLevel: parseInt(document.getElementById('difficulty-level').value) || 3,
                bpm: parseInt(document.getElementById('song-bpm').value) || 120,
                // We don't upload the audio file itself to keep it simple/light
                // Users must have the audio locally or we could implement audio upload later
                // For now, we just save the map metadata and notes.
                // NOTE: To make it playable for others, we really SHOULD upload audio...
                // But for this MVP, let's assume standard assets or just code logic.
                // WAIT: If we don't upload audio, others can't play it.
                // Let's include audioData (base64) IF it's small enough, otherwise warn.
                audioData: audioData,
                backgroundData: backgroundData,
                notes: notes
            };

            // Size check
            const json = JSON.stringify(mapData);
            const sizeMB = (json.length / (1024 * 1024)).toFixed(2);
            if (sizeMB > 10) {
                if (!confirm(`Map size is ${sizeMB}MB (due to audio/bg). Upload might be slow or fail. Continue?`)) return;
            }

            // Get session token for auth
            const sessionToken = new URLSearchParams(window.location.search).get('session_token') || localStorage.getItem('rhythm_circle_session');

            try {
                const response = await fetch('/api/rhythm/maps', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${sessionToken}`
                    },
                    body: JSON.stringify({
                        title: mapData.title,
                        artist: mapData.artist,
                        game_id: 'rhythm_circle',
                        data: mapData
                    })
                });

                const result = await response.json();

                if (response.ok) {
                    alert('Map uploaded successfully!');
                } else {
                    alert('Upload failed: ' + (result.error || 'Unknown error'));
                }
            } catch (e) {
                console.error("Upload error", e);
                alert("Network error during upload.");
            }
        }

        // ===== LIVE RECORDING =====
        function toggleRecordMode() {
            isRecording = !isRecording;

            // Update header record button
            const headerBtn = document.getElementById('record-btn');
            if (headerBtn) {
                if (isRecording) {
                    headerBtn.style.background = '#ff3366';
                    headerBtn.style.color = '#fff';
                    headerBtn.textContent = '⏺ Recording...';
                } else {
                    headerBtn.style.background = '';
                    headerBtn.style.color = '';
                    headerBtn.textContent = '⏺ Record';
                }
            }

            // Update timeline record button
            const timelineBtn = document.getElementById('timeline-record-btn');
            if (timelineBtn) {
                if (isRecording) {
                    timelineBtn.style.background = '#aa0000';
                    timelineBtn.style.color = 'white';
                } else {
                    timelineBtn.style.background = '';
                    timelineBtn.style.color = '#ff5555';
                }
            }

            // Auto-start playback when recording starts
            if (isRecording && !isPlaying && audio) {
                togglePlay();
            }
        }

        // Live recording keydown handler - stores key press start times
        function handleRecordingKeyDown(e) {
            if (!isRecording || !isPlaying || !audio) return;
            if (e.target.tagName === 'INPUT') return;

            // Ignore if key currently held
            if (recordingKeys[e.code]) return;

            // Record the start time for this key
            recordingKeys[e.code] = audio.currentTime * 1000;
        }

        // Add recording keydown listener
        document.addEventListener('keydown', handleRecordingKeyDown);

        document.addEventListener('keyup', (e) => {
            if (isRecording && isPlaying && audio && recordingKeys[e.code]) {
                const startTime = recordingKeys[e.code];
                const endTime = audio.currentTime * 1000;
                const duration = endTime - startTime;

                delete recordingKeys[e.code];

                // Determine Input Type based on key? 
                // For simplicity, let's say: Z/X = Red/Blue? Or just use current tool?
                // User said "if i hold it adds hold note".

                let type = currentTool;
                if (type === 'hold' || type === 'spam') type = 'blue'; // Default to normal note color unless explicit

                // Check duration for Auto-Hold
                let finalNote = {
                    time: startTime,
                    type: type,
                    angle: 0
                };

                if (duration > 200) { // If held for more than 200ms, make it a hold note
                    finalNote.type = 'hold';
                    finalNote.endTime = endTime;
                }

                // Apply Snapping?
                // Probably better to record raw, but user asked for Play Placement.
                // Let's add option or just raw. Most rhythm game editors use snapping or partial snapping.
                // Let's snap the START time to nearest 1/16 or current snap setting?

                const snapDivisor = parseInt(document.getElementById('snap-select').value);
                if (snapDivisor > 0) {
                    const bpm = parseInt(document.getElementById('song-bpm').value) || 120;
                    const msPerBeat = 60000 / bpm;
                    const msPerSnap = msPerBeat / (snapDivisor / 1);
                    finalNote.time = Math.round(finalNote.time / msPerSnap) * msPerSnap;
                    if (finalNote.endTime) {
                        finalNote.endTime = Math.round(finalNote.endTime / msPerSnap) * msPerSnap;
                    }
                }

                saveState(); // Save before adding recorded note
                notes.push(finalNote);
                notes.sort((a, b) => a.time - b.time);
            }
        });

        // ===== SAVING =====
        function saveDraft() {
            const data = {
                title: document.getElementById('song-title').value,
                artist: document.getElementById('song-artist').value,
                difficulty: document.getElementById('song-difficulty').value,
                difficultyLevel: document.getElementById('difficulty-level').value,
                bpm: document.getElementById('song-bpm').value,
                notes: notes,
                backgroundFilename: backgroundFilename,
                backgroundData: backgroundData, // Include large data
                audioData: audioData // Include large data
            };

            // Use IndexedDB for drafts (Bypasses localStorage limit)
            const request = indexedDB.open('RhythmCircleDB', 2); // Ensure v2 for drafts store

            request.onupgradeneeded = function (event) {
                const db = event.target.result;
                if (!db.objectStoreNames.contains('playtest')) {
                    db.createObjectStore('playtest', { keyPath: 'id' });
                }
                if (!db.objectStoreNames.contains('drafts')) {
                    db.createObjectStore('drafts', { keyPath: 'id' });
                }
            };

            request.onsuccess = function (event) {
                const db = event.target.result;

                // If drafts store is missing (older version opened), we must upgrade
                if (!db.objectStoreNames.contains('drafts')) {
                    db.close();
                    const upgradeReq = indexedDB.open('RhythmCircleDB', 2);
                    upgradeReq.onupgradeneeded = function (ev) {
                        const d = ev.target.result;
                        if (!d.objectStoreNames.contains('drafts')) {
                            d.createObjectStore('drafts', { keyPath: 'id' });
                        }
                    };
                    upgradeReq.onsuccess = function (ev) {
                        saveDraft(); // Retry
                    };
                    return;
                }

                const transaction = db.transaction(['drafts'], 'readwrite');
                const store = transaction.objectStore('drafts');

                const putRequest = store.put({ id: 'autosave', data: data });

                putRequest.onsuccess = function () {
                    const now = new Date();
                    const el = document.getElementById('last-saved');
                    if (el) el.textContent = 'Last saved: ' + now.toLocaleTimeString();
                };

                putRequest.onerror = function (e) {
                    console.error("Draft Save Error", e);
                    alert("Failed to save draft to DB: " + e.target.error);
                };
            };

            request.onerror = function (e) {
                console.error("IDB Open Error", e);
                // Fallback to localStorage logic if DB fails completely
                try {
                    localStorage.setItem('rhythm_circle_draft', JSON.stringify(data));
                } catch (err) {
                    // ignore
                }
            };
        }

        function loadDraft() {
            // Try loading from IndexedDB first (v2)
            const request = indexedDB.open('RhythmCircleDB', 2);

            request.onsuccess = function (event) {
                const db = event.target.result;
                if (!db.objectStoreNames.contains('drafts')) {
                    loadDraftFromLocalStorage(); // Fallback
                    return;
                }

                const transaction = db.transaction(['drafts'], 'readonly');
                const store = transaction.objectStore('drafts');
                const getRequest = store.get('autosave');

                getRequest.onsuccess = function (e) {
                    const result = e.target.result;
                    if (result && result.data) {
                        loadDataIntoEditor(result.data);
                        console.log("Draft loaded from IndexedDB");
                    } else {
                        loadDraftFromLocalStorage();
                    }
                };

                getRequest.onerror = function () {
                    loadDraftFromLocalStorage();
                };
            };

            request.onerror = function () {
                loadDraftFromLocalStorage();
            };
        }

        function loadDraftFromLocalStorage() {
            const draft = localStorage.getItem('rhythm_circle_draft');
            if (!draft) {
                // Silent fail or console log, autosave load is usually silent unless manual
                // But if manual load button:
                // alert('No draft found.'); 
                return;
            }
            try {
                loadDataIntoEditor(JSON.parse(draft));
            } catch (e) {
                console.error("Failed to parse local draft", e);
            }
        }

        function loadDataIntoEditor(data) {
            document.getElementById('song-title').value = data.title || '';
            document.getElementById('song-artist').value = data.artist || '';
            document.getElementById('song-difficulty').value = data.difficulty || 'Normal';
            document.getElementById('difficulty-level').value = data.difficultyLevel || 3;
            document.getElementById('song-bpm').value = data.bpm || 120;
            notes = data.notes || [];
            backgroundFilename = data.backgroundFilename || '';
            backgroundData = data.backgroundData || null;
            document.getElementById('bg-filename').textContent = backgroundFilename || 'No background';

            // Load background image from saved data
            if (backgroundData) {
                const img = new Image();
                img.onload = () => {
                    backgroundImage = img;
                    drawPreview();
                };
                img.src = backgroundData;
            } else {
                backgroundImage = null;
            }

            // Load audio from saved data
            if (data.audioData) {
                audioData = data.audioData;
                audio = new Audio(audioData);
                audio.addEventListener('loadedmetadata', () => {
                    updateTimeline();
                });
                audio.addEventListener('ended', () => {
                    isPlaying = false;
                    document.getElementById('play-btn').textContent = '▶';
                    if (isPlaytesting) {
                        endPlaytest();
                    }
                });
            }

            updateTimeline();
            drawPreview();

            const lastSavedEl = document.getElementById('last-saved');
            if (lastSavedEl) lastSavedEl.textContent = 'Draft loaded';
        }

        // ===== CONTEXT MENU & SHORTCUTS =====
        function deleteSelectedNotes() {
            hideContextMenu();
            if (selectedNotes.size === 0) return;
            saveState(); // Save before delete
            // Filter out selected notes
            notes = notes.filter((_, index) => !selectedNotes.has(index));
            selectedNotes.clear();
            updateTimeline();
        }

        function copySelectedNotes() {
            hideContextMenu();
            copiedNotes = notes.filter((_, index) => selectedNotes.has(index)).map(n => ({ ...n })); // Deep copy
        }

        function pasteNotes() {
            hideContextMenu();
            if (copiedNotes.length === 0) return;
            saveState(); // Save before paste
            // Paste at current playhead or just offset?
            // Let's offset by 1 beat (500ms approx)
            const offset = 500;
            copiedNotes.forEach(note => {
                const newNote = { ...note };
                newNote.time += offset;
                if (newNote.endTime) newNote.endTime += offset;
                notes.push(newNote);
            });
            notes.sort((a, b) => a.time - b.time);
            updateTimeline();
        }

        function toggleNoteType() {
            hideContextMenu();
            saveState(); // Save before type change
            selectedNotes.forEach(index => {
                const note = notes[index];
                if (note.type === 'red') note.type = 'blue';
                else if (note.type === 'blue') note.type = 'hold';
                else if (note.type === 'hold') note.type = 'spam';
                else note.type = 'red';

                // Add/Remove endTime if switching to/from hold
                if (note.type === 'hold' && !note.endTime) note.endTime = note.time + 1000;
                if (note.type !== 'hold') delete note.endTime;
            });
            updateTimeline();
        }

        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT') return; // Ignore if typing in input

            if (e.key === 'Delete' || e.key === 'Backspace') {
                deleteSelectedNotes();
            }
            if (e.ctrlKey && e.code === 'KeyC') {
                copySelectedNotes();
            }
            if (e.ctrlKey && e.code === 'KeyV') {
                pasteNotes();
            }
            if (e.ctrlKey && e.code === 'KeyZ') {
                e.preventDefault();
                undo();
            }
            if (e.ctrlKey && e.code === 'KeyY') {
                e.preventDefault();
                redo();
            }
        });
    </script>
</body>

</html>